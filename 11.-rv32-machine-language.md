# 11. RV32 Machine Language

Computer only understands 1s and 0s

RISC-V’s 32b instruction words are divided into fields.&#x20;

Each field tells processor something about the instruction.

| R-Format | Register-register arithmetic operations         |
| -------- | ----------------------------------------------- |
| I-Format | Register-immediate arithmetic operations; Loads |
| S-Format | Stores                                          |
| B-Format | Branches (minor variant of S-format)            |
| U-Format | 20-bit upper immediate instructions             |
| J-Format | Jumps (minor variant of U-format)               |



## R-Format

Register-Register Arithmetic Instructions (add, xor, sll, etc.)

<mark style="color:yellow;">**opname rd, rs1, rs2**</mark>

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

## I-Format

Immediate Fields Instruction

<mark style="color:yellow;">**opname rd, rs1, imm**</mark>

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

## I-Format: Load

Load Instructions Are Also I-Format

Load address = (Base Register) + (Immediate Offset)

<mark style="color:yellow;">**loadop rd, imm(rs1)**</mark>

## S-Format

S-Format Instruction Layout

Store address = (Base Register) + (Immediate Offset)

<mark style="color:yellow;">**storeop rs2, imm(rs1)**</mark>

<figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

## The Program Counter (PC)

PC-Relative Addressing: Supply a signed offset to update PC.&#x20;

* PC = PC + byte\_offset
* “Position-Independent Code”: If all of code moves, relative offsets don’t change!
* Branches generally change the PC by a small amount, therefore in RISC-V instructions we encode relative offsets as signed immediates.

Contrast with: Absolute Addressing Supply new address to overwrite PC.&#x20;

* PC = new\_address&#x20;
* Use sparingly: Brittle to code movement/need to build 32-bit immediate (more later)

## B-Format

In units of 2 bytes (16-bit “half-words”).&#x20;

* One branch reaches ± 2^10 x 32-b instructions from PC.&#x20;
* Multiply the offset by 2 before adding to the PC.



* RISC-V Base ISA for RV32, RV64, RV128 all have 32-bit wide instructions, but it supports extensions: 16b compressed instructions
* RISC-V Conditional Branches can only reach ±210 32-bit instructions on either side of PC.

close to S-Format

<mark style="color:yellow;">**opname rs1,rs2,Label**</mark>

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

Immediate represents relative offset in increments of 2 bytes (“half-words”)

* To compute new PC: PC = PC + byte\_offset.&#x20;
* 12 immediate bits imply ±2^10 32-bit instructions reachable:&#x20;
  * 1 bit: 2’s complement (allow +/– offset)&#x20;
  * 1 bit: half-word/16-b instruction support

±2^10 32-bit = 2^1 \* 2^10 \* 2^2 = 2^13, total 13bits, but LSB is not saved.

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

Conditionally Branching Even Further

* Enter the unconditional jump!
*   Code:\
    beq x10, x0, far

    \# next instr\
    \
    &#x20;         bne x10, x0, next

    &#x20;         j far

    next: # next instr

## J-Format

Two use cases:

* Call a function (and simultaneously save return address in named register) \
  jal ra, FuncLabel
*   Unconditional branch j pseudoinstruction: jump and discard return address Often used to conditionally branch further than B-Types\
    j Label

    jal x0, Label



<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

Immediate represents relative offset in increments of <mark style="color:red;">2 bytes</mark>.

* To compute new PC:  PC = PC + byte\_offset.
* 20 immediate bits imply ±2^18 32-bit instructions reachable:
  * 1 bit: 2’s complement (allow +/– offset), 1 bit: half-word/16-b instruction support
* Immediate bit encoding optimized to reduce HW cost

## U-Format: Long Immediates

“Upper Immediate” instructions:

<mark style="color:yellow;">**opname rd,immed**</mark>

<figure><img src=".gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Immediate represents upper 20 bits of a 32-bit immediate operand imm = immed << 12.



<mark style="color:yellow;">**lui rd,immed**</mark>

rd = immed << 12

The lui instruction, Load Upper Immediate:&#x20;

* Write a 20-bit immediate value into the upper 20-bits of register rd.&#x20;
* Clear the lower 12 bits.

## lui together with an addi

lui together with an addi (to set lower 12 bits) can create any 32-bit value in a register:

```
// Some code
lui x10, 0x87654     # x10 = 0x87654000
addi x10, x10, 0x321 # x10 = 0x87654321
```

How should we set the immediate 0xB0BACAFE?&#x20;

Unfortunately: Recall: addi sign-extends the 12-bit immediate.&#x20;

If “sign bit” set, subtracts 1 from the upper 20-bits!



```
// Some code
lui x10, 0xB0BAC        # x10 = 0xB0BAC000
addi x10, x10, 0xAFE    # x10 = 0xB0BABAFE
```

Solution: If 12-bit immediate is negative, add 1 to the upper 20-bit load.

```
// Some code
lui x10, 0xB0BAD     # x10 = 0xB0BAD000
addi x10, x10, 0xAFE # x10 = 0xB0BACAFE
```



<mark style="color:yellow;">**li rd, immed**</mark>

The li pseudoinstruction (Load Immediate) resolves to lui + addi as needed, e.g., li x10,0x87654321

Use pseudoinstructions! li automatically handles this edge case.







## auipc loads the PC into the Register File

<mark style="color:yellow;">**auipc rd,immed**</mark>

rd = PC + (immed << 12)

The auipc instruction Adds an Upper Immediate to the PC.

Example:&#x20;

auipc x5, 0xABCDE # x5 = PC + 0xABCDE000&#x20;

In Practice:&#x20;

Label: auipc x5, 0 # puts address of Label in x5&#x20;

Loads the PC into a register accessible by other instructions.

auipc is most often used together with jalr to do PC-relative addressing with super large offsets.



## jalr: I-Format

§jalr does a Jump And Link Register:

<mark style="color:yellow;">**jalr rd,rs1,imm**</mark>

* Jump to rs1 + imm.&#x20;
* Write address of the following instruction to rd.

PC = rs1 + imm

rd = PC + 4



<mark style="color:yellow;">**jalr rd,rs1,imm**</mark>

<figure><img src=".gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

imm and rs1 are added together to update PC.

PC = rs1 + imm

⚠️Note I-Type!\
Unlike B-type, J-type, jalr will not multiply imm by 2.▫Immediate offset therefore must be written in units of bytes.

{% hint style="danger" %}
Unlike jal (relative to PC), jalr addresses are relative to rs1, which is modifiable by arithmetic instructions. We can do bigger jumps!
{% endhint %}

Use cases (so far):&#x20;

* Return to caller\
  jr ra (jalr x0, ra, 0)
*   Call a function (and save return address) at any 32-bit absolute address. \
    lui x1 \<hi20bits>

    jalr ra, x1, \<lo12bits>
*   Jump PC-relative with a 32-bit offset.\
    auipc x1 \<hi20bits>

    jalr x0, x1, \<lo12bits>
