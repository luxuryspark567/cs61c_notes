# 19. RISC V Datapath II

## Implementing Loads

lw x14, 8(x2)

lw uses I-Format:

<figure><img src=".gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

* Similar datapath to addi, but creates an address (not the final value stored).&#x20;
  * addr = (Base register rs1) + (sign-extended imm offset)
* State element access now includes a memory read!&#x20;
  * DMEM (read word at address addr)&#x20;
  * RegFile Reg\[rs1] # read; Reg\[rd] # write&#x20;
  * PC PC = PC + 4

<figure><img src=".gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

* To support narrower loads (lb, lh, lbu, lhu):&#x20;
  * Load 32-bit word from memory;&#x20;
  * Add additional logic to extract correct byte or halfword; and&#x20;
  * Sign- or zero-extend result to 32 bits to write into RegFile.&#x20;
  * Can be implemented with MUX + and a few gates.

## Implementing Stores

sw x14, 36(x2)

S-Format:

<figure><img src=".gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

* New Immediate Format:&#x20;
  * addr = (Base register rs1) + (sign-extended imm offset)&#x20;
* State Elements Accessed:&#x20;
  * DMEM (write R\[rs2] to word at address addr)&#x20;
  * RegFile R\[rs1] (base address), R\[rs2] (value to store)&#x20;
  * PC PC = PC + 4

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

## Adding B-Type (Branches)

opname rs1,rs2,Label

B-Format (textbook: SB-Type) close to S-Format:

<figure><img src=".gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

* New Immediate Format!
* PC state element now conditionally changes:
  * RegFile  R\[rs1], R\[rs2] (read only, for branch comparison)
  * PC  PC = PC + imm  (if branch taken)\
    &#x20;      PC = PC + 4    (otherwise, not taken)

### The Branch Comparator Block

<figure><img src=".gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (10).png" alt="" width="375"><figcaption></figcaption></figure>

* The Branch Comparator is a combinational logic block.&#x20;
  * Input:&#x20;
    * Two data busses A and B (datapath R\[rs1] and R\[rs2], respectively)&#x20;
    * BrUn (“Branch Unsigned”) control bit&#x20;
  * Output:&#x20;
    * BrEq flag: 1 if A == B&#x20;
    * BrLT flag: 1 if A < B. Unsigned comparison if BrUn=1, signed otherwise.
* Control Logic:&#x20;
  * Set BrUn based on current instruction, inst\[31:0].&#x20;
  * Set PCSel based on branch flags BrLT, BrEq.

<figure><img src=".gitbook/assets/image (9).png" alt="" width="563"><figcaption></figcaption></figure>

### The ALU computes PC + Imm

<figure><img src=".gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

## Designing the Immediate Generation Block, Part 2

I-Type and S-Type Immediates

<figure><img src=".gitbook/assets/image (158).png" alt=""><figcaption></figcaption></figure>

B-Type Immediates

<figure><img src=".gitbook/assets/image (159).png" alt=""><figcaption></figcaption></figure>



## Adding Jumps jal, jalr

jal rd, Label

J-Format:

<figure><img src=".gitbook/assets/image (161).png" alt=""><figcaption></figcaption></figure>

* New immediate format!
* State Elements updated:
  * PC  PC = PC + imm   (unconditional PC-relative jump)
  * RegFile  R\[rd] = PC + 4

<figure><img src=".gitbook/assets/image (162).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (163).png" alt=""><figcaption></figcaption></figure>

## I-Format Instruction Layout: jalr

jalr rd,rs1,imm

jalr uses I-Format:

<figure><img src=".gitbook/assets/image (164).png" alt=""><figcaption></figcaption></figure>

* Two changes to state:
  * PC  PC = R\[rs1] + imm   (absolute addressing)
  * RegFile  R\[rd] = PC + 4
* I-Format means jalr uses the same immediates as arithmetic/loads!
  * In other words, <mark style="color:red;">imm is already a byte offset</mark>.

<figure><img src=".gitbook/assets/image (165).png" alt=""><figcaption></figcaption></figure>

## Adding U-Types

opname rd,immed

“Upper Immediate” instructions:

<figure><img src=".gitbook/assets/image (166).png" alt=""><figcaption></figcaption></figure>

* New immediate format!
* Used for two instructions:
  * lui: Load Upper Immediate
  * auipc: Add Upper Immediate to PC
  * Both increment PC to next instruction and save to destination register.

<figure><img src=".gitbook/assets/image (167).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (168).png" alt=""><figcaption><p>Lighting the LUI Datapath</p></figcaption></figure>

<figure><img src=".gitbook/assets/image (169).png" alt=""><figcaption><p>Lighting the AUIPC Datapath</p></figcaption></figure>

## Conclusion RV32I Datapath!

<figure><img src=".gitbook/assets/image (170).png" alt=""><figcaption></figcaption></figure>

