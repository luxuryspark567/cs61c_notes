# 9. Decision Making Logical Ops

## Review

* Memory is byte-addressable, but lw and sw access one word at a time.
* A pointer (used by lw and sw) is just a memory address, we can add to it or subtract from it (using offset).
* Big- vs Little EndianoTip: draw lowest byte on the right
* New Instructions:
  * lw, sw, lb, sb, lbu

## RV32 so far

* Addition/subtraction
  * add rd, rs1, rs2
  * sub rd, rs1, rs2
* Add immediate
  * addi rd, rs1, imm
* Load/store
  * lw  rd,  rs1, imm
  * lh rd, rs1, imm
  * lb  rd,  rs1, imm
  * lbu rd,  rs1, imm
  * sw  rs1, rs2, imm
  * sb  rs1, rs2, imm
* Branching
  * beq  rs1, rs2, Label
  * bne  rs1, rs2, Label
  * bge  rs1, rs2, Label
  * blt  rs1, rs2, Label
  * bgeu rs1, rs2, Label
  * bltu rs1, rs2, Label
  * j Label

## Types of Branches

* Conditional Branch – change control flow depending on outcome of comparison&#x20;
  * branch if equal (`beq`) or branch if not equal (`bne`)&#x20;
  * Also branch if less than (`blt`) and branch if greater than or equal (`bge`)&#x20;
  * And unsigned versions (`bltu, bgeu`)
* Unconditional Branch – always branch&#x20;
  * a RISC-V instruction for this: `jump (j)`, as in j label

## Example if Statement

Assuming translations below, compile if block

&#x20;f → x10; g → x11; h → x12;  i → x13; j → x14;

```c
if (i == j)  
  f = g + h;
```

```wasm
bne x13,x14,Exit
add x10,x11,x12
Exit:
```

## Example if-else Statement

Assuming translations below, compile

&#x20; f → x10  g → x11    h → x12  i → x13    j → x14

```c
if (i == j)
    f = g + h; 
else
    f = g – h;
```

```wasm
bne x13,x14,Else 
add x10,x11,x12 
j Exit 
Else:sub x10,x11,x12
Exit: 
```

## RISC-V magnitude-compare branches:

* “Branch on Less Than”
  * Syntax:        **`blt`**` ``reg1,reg2, Labe`l
  * Meaning:    <mark style="color:green;">if (reg1 < reg2) goto Label;</mark>
* “Branch on Less Than Unsigned”
  * Syntax:        **`bltu`**` ``reg1,reg2, Label`
  * Meaning:  <mark style="color:green;">if (reg1 < reg2)  goto label;</mark> // treat registers as unsigned integers
* Also “Branch on Greater or Equal” **bge** and **bgeu**

{% hint style="danger" %}
Note: No ‘bgt’ or ‘ble’ instructions
{% endhint %}

## Loops in C/Assembly

Though there are multiple ways of writing a loop in RISC-V, the key to <mark style="color:red;">decision-making is conditional branch</mark>

* while
* do … while
* for



```
int A[20];
// fill A with data
int sum = 0;
for (int i=0; i < 20; i++)
    sum += A[i];
```

```wasm
  add x9, x8, x0 # x9=&A[0]
  add x10, x0, x0 # sum=0
  add x11, x0, x0 # i = 0
  addi x13,x0, 20 # x13 = 20
Loop:
  bge x11,x13,Done
  lw x12, 0(x9)   # x12=A[i]
  add x10,x10,x12 # sum+=x12
  addi x9, x9,4   # &A[i+1]
  addi x11,x11,1  # i++
  j Loop
Done:  
```

## RISC-V Logical Instructions

| Logical operations   | <p>C</p><p>operators</p> | Java operators | RISC-V instructions |
| -------------------- | ------------------------ | -------------- | ------------------- |
|  Bit-by-bit AND      | &                        | &              | and                 |
|  Bit-by-bit OR       | \|                       | \|             | or                  |
|  Bit-by-bit XOR      | ^                        | ^              | xor                 |
|  Shift left logical  | <<                       | <<             | sll                 |
|  Shift right logical | >>                       | >>             | srl                 |

## RISC-V Logical Instructions

* Always two variants&#x20;
  * Register: and x5, x6, x7 # x5 = x6 & x7&#x20;
  * Immediate: andi x5, x6, 3 # x5 = x6 & 3&#x20;
* Used for ‘masks’&#x20;
  * andi with 0000 00FFhex isolates the least significant byte&#x20;
  * andi with FF00 0000hex isolates the most significant byte

## No NOT in RISC-V

XOR is conditional inverter:

* when x is zero, result the same with y;
* when x is one, result is the opposite of y;

NOT is to use xor with 0xFF

<figure><img src=".gitbook/assets/image (85).png" alt="" width="375"><figcaption></figcaption></figure>

## Logical Shifting (<mark style="color:red;">zero extending</mark>)

* Shift Left Logical (sll) and immediate (slli): \
  slli x11,x12,2 #x11=x12<<2&#x20;

## Arithmetic Shifting (<mark style="color:red;">sign extending</mark>)

* Shift right arithmetic (sra, srai) moves n bits to the right (insert high-order sign bit into empty bits)
  * For positive numbers, shift right is the same as divided by 2^n;
  * For nodd negative numbers, shift right is NOT same as dividing by 2^n, because C arithmetic semantics is that division should round towards 0.

## Helpful RISC-V Assembler Features

* Symbolic register names&#x20;
  * E.g., a0-a7 for argument registers (x10-x17) for function calls&#x20;
  * E.g., zero for x0&#x20;
* Pseudo-instructions&#x20;
  * Shorthand syntax for common assembly idioms&#x20;
  * E.g., mv rd, rs = addi rd, rs, 0&#x20;
  * E.g., li rd, 13 = addi rd, x0, 13&#x20;
  * E.g., nop = addi x0, x0, 0
