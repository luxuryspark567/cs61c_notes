# 13. CALL(Compiling, Assembling, Linking, and Loading)

## Pseudoinstructions

| Pseudoinstruction | Real instruction(s)                                                            |                                                                                     |
| ----------------- | ------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------- |
| mv rd rs1         | addi rd rs1 0                                                                  |                                                                                     |
| not rd rs         | xori rd rs -1                                                                  |                                                                                     |
| li rd imm         | <p># &#x3C;= 12-bit signed imm</p><p>addi rd x0 imm</p>                        | <p># >12-bit immediate</p><p>lui rd imm[31:12]</p><p>addi rd rd imm[11:0]</p>       |
| j Label           | jal x0 label                                                                   |                                                                                     |
| jr rs1            | jalr x0 rs1 0                                                                  |                                                                                     |
| la rd label       | <p># absolute address</p><p>lui rd addr[31:12]</p><p>addi rd rd addr[11:0]</p> | <p># PC-relative address</p><p>auipc rd addr[31:12]</p><p>addi rd rd addr[11:0]</p> |
| call label        | <p>auipc ra addr[31:12]</p><p>jalr ra ra addr[11:0]</p>                        | Compilers often use call for jal far\_away, e.g., in a different file.              |

## Compiler vs Interpreter

* Compiler (Translating): Converts the source language to another language. Translatingto lower-level languages almost always means higher efficiency, higher performance.
* Interpreter: Directly executes a program in the source language
  * Venus RISC-V simulator useful for learning/debugging

<figure><img src=".gitbook/assets/image (91).png" alt=""><figcaption></figcaption></figure>

* Compiler
  * Highlevel language to assemly language.
  * Assembly code may contain pseudoinstructions! e.g., mv, li, call, j, etc.
* Assembler
  * The assembler is primarily responsible for <mark style="color:red;">replacing pseudoinstructions and resolving offsets (</mark>relative addressing<mark style="color:red;">)</mark>.
  * Output:&#x20;
    * Object File: Machine Language Module (e.g., foo.o for RISC-V)&#x20;
    * Object Code (machine language) Information for linking and debugging&#x20;
      * <mark style="color:red;">Symbol Table</mark>, <mark style="color:red;">Relocation Information</mark>, <mark style="color:red;">Data Segment</mark>, etc.&#x20;
  * Reads and uses directives&#x20;
  * Replaces pseudoinstructions with true assembly, then, produce machine language code
* Linker
  * Relocate absolute address references.
  *

## Directives

give directions to the assembler:&#x20;

* Often generated by the compiler (previous stage)&#x20;
* Directives do not produce machine instructions!&#x20;
* Rather, they inform how to build different parts of the object file.

<table data-header-hidden><thead><tr><th width="151"></th><th></th></tr></thead><tbody><tr><td><p>.text</p><p>    …</p></td><td>Subsequent items put in user Text segment<br>(machine code)</td></tr><tr><td><p>.data</p><p>    …</p></td><td>Subsequent items put in user Data segment<br>(source file data in binary)</td></tr><tr><td>.globl sym</td><td>Declares sym global and can be referenced from other files</td></tr><tr><td>.string str</td><td>Store the string str in memory and null-terminate it</td></tr><tr><td>.word w1 … wn</td><td>Store the n 32-bit quantities in successive memory words</td></tr></tbody></table>

## Object File Format

* **Object File Header**: size and position of the other parts&#x20;
* **Text Segment**: machine code&#x20;
* **Data Segment**: binary representation of static data in the source file
* **Symbol Table**: List of file’s labels, static data that can be referenced by other programs&#x20;
* **Relocation Information**: Identifies lines of code that need to be “handled” by the Linker (jumps to external labels (e.g. lib files), references to static data)
* **Debugging Information**: Additional information for debuggers

## Producing Machine Code

* Simple case:&#x20;
  * Arithmetic, Logical, Shifts, etc.&#x20;
  * All necessary info is within the instruction already!
* PC-Relative Branches and Jumps:&#x20;
  * e.g., beq/bne/etc. and jal&#x20;
  * Position-Independent Code (PIC):&#x20;
    * Once pseudoinstructions are replaced with real ones, all PC-relative addressing can be computed&#x20;
  * Determine the offset to encode by counting the number of <mark style="color:red;">half-word</mark> instructions between current instruction and target instruction
  * Two-Pass  Addresses:&#x20;
    * Pass 1: Remember positions of labels (store in symbol table).&#x20;
    * Pass 2: Use label positions to generate machine code.

## Other References?

* References to other files?&#x20;
  * e.g., call-ing strlen from the C string library&#x20;
* References to static data?&#x20;
  * e.g., la gets broken up until lui and addi&#x20;
  * These require knowing the full 32-bit address of the data
* These can’t be determined yet, so the Assembler jots them down in two tables: <mark style="color:red;">Relocation Information</mark> and <mark style="color:red;">Symbol Table</mark>.

## Symbol Table

* List of “items” in this file&#x20;
* Instruction Labels&#x20;
  * Used to compute machine code for PC-relative addressing in branches, function calling, etc.&#x20;
  * .global directive: labels can be referenced by other files.&#x20;
* Data: anything in the .data section&#x20;
* Global variables may be accessed/used by other files.

## Relocation Information

* List of “items” whose address this file needs&#x20;
* Any external label jumped to External label (including lib files):&#x20;
  * jal ext\_label&#x20;
* Any piece of data in static section&#x20;
  * e.g., la instruction (for lw/sw base register)

## Linker Patches Together Multiple Object Modules

* Put together text segments from each .o file.&#x20;
* Put together data segments from each .o file, then concatenate this onto the end of Step 1’s segment.&#x20;
* Resolve references.&#x20;
  * Go through Relocation Table and handle each entry, i.e., fill in all absolute addresses.

## Which Addresses Need Relocating?

* PC-Relative Addressing beq, bne, jal, auipc/addi, etc.
  *   Never relocate

      Position-independent code (PIC)
* External Function Reference usually jal or auipc/jalr
  *   Always relocate

      Addresses were unknown at time of assembling
* Static Data Reference lw, sw, lui/addi
  *   Always relocate

      Data segment has relocated

## Which Instructions Need Relocation Editing?

* J-Format (only when jumping externally!)
* Loads and stores using gp to access .data variables&#x20;
  * Global pointer (gp), is a pointer to the data/static segment.
* lui, addi; auipc/jalr (if jumping externally)&#x20;
* Again, conditional branches (B-Type) DO NOT need editing! PC-relative addressing preserved even if text is relocated

## Resolving References

* For RV32, linker assumes first text segment starts at address 0x10000. (More later: virtual memory)&#x20;
* Linker knows:&#x20;
  * Length of each text/data segment&#x20;
  * Ordering of text and segments&#x20;
* Linker calculates:&#x20;
  * Absolute address of each label to be jumped to and of each piece of data referenced.
* Linker resolves references:
  * Search for reference (data or label) in all ”user” symbol tables.
  * If not found, search library files (e.g., for printf).
  * Once absolute address determined, fill in machine code appropriately.
* Linker Output:
  * Executable containing text and data (+ header/debugging info)

## Static vs. Dynamic Linking

* statically-linked libraries.&#x20;
  * The library is now part of the executable – if the library updates, we won’t get the fix unless we recompile the user program.&#x20;
  * The executable includes the entire library, even if not all of it is used by the user program.&#x20;
  * Pro: The Executable is self-contained!
* dynamically-linked libraries (DLL), common on Windows & UNIX Platforms.



## Loader

* Load program into a newly created address space:&#x20;
  * Read executable’s file header for sizes of text, data segments.&#x20;
  * Create new address space for program large enough to hold text and data segments, along with a stack segment.&#x20;
  * Copy instructions, data from executable file into new address space.&#x20;
  * Copy arguments passed to the program onto the stack.&#x20;
* Initialize machine registers&#x20;
  * Most registers cleared; stack pointer (sp) assigned address of first free stack location&#x20;
* Jump to start-up routine, which does the following:&#x20;
  * Copy program arguments from stack to registers, set PC&#x20;
  * If main routine returns, terminate program with exit system call.











