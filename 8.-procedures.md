# 8. Procedures

## Six Fundamental Steps in Calling a Function

1. Put arguments in a place where function can access them&#x20;
2. Transfer control to function&#x20;
3. Acquire (local) storage resources needed for function&#x20;
4. Perform desired task of the function&#x20;
5. Put return value in a place where calling code can access it and restore any registers you used; release local storage&#x20;
6. Return control to point of origin, since a function can be called from several points in a program

## RISC-V Function Call Conventions

* Registers faster than memory, so use them&#x20;
* a0–a7 (x10-x17): eight argument registers to pass parameters and two return values (a0-a1)&#x20;
* ra: one return address register to return to the point of origin (x1)&#x20;
* Also s0-s1 (x8-x9) and s2-s11 (x18-x27): saved registers (more about those later)

## RISC-V Function Call Instructions

*   Invoke function: jump and link instruction (jal) (really should be laj “link and jump”)

    * “link” means form an address or link that points to\
      calling site to allow function to return to proper address
    * Jumps to address and simultaneously saves the address of the following instruction in register rd

    <figure><img src=".gitbook/assets/image (7).png" alt="" width="375"><figcaption></figcaption></figure>
* Return from function: jump register instruction (jr)&#x20;
  * Unconditional jump to address specified in register: jr ra&#x20;
  * Assembler short-hand: <mark style="color:yellow;">**ret = jr ra**</mark>

## Summary of Instruction Support

* Actually, only two instructions:
  * <mark style="color:yellow;">**jal  rd, Label**</mark> – jump-and-link # rd = pc+4; pc += imm
  * <mark style="color:yellow;">**jalr rd, rs, imm**</mark> – jump-and-link register # rd = pc+4; pc = R\[rs1]+imm
    * As we’re going to see, “ain’t no free lunch”, so there might not be enough bits left for the Label to go as far as we want to jump.
    * With jalr, we jump to the contents of the register rs + immediate imm (like a base pointer and offset) and set rd as in jal
* <mark style="color:yellow;">**j**</mark>, <mark style="color:yellow;">**jr**</mark> and <mark style="color:yellow;">**ret**</mark> are <mark style="color:red;">pseudoinstructions</mark>!
  * j:   jal  x0, Label

## Function Call Example

```c
int Leaf (int g, int h, int i, int j)
{
		int f;
		f = (g + h) – (i + j);
		return f;
}
/*
Parameter variables g, h, i, and j in 
argument registers a0, a1, a2, and a3, 
and f in s0.
Assume need one temporary register s1
*/
```

```wasm
Leaf: 	addi sp,sp,-8 # adjust stack for 2 items
		sw s1, 4(sp)  # save s1 for use afterwards
      	sw s0, 0(sp)  # save s0 for use afterwards

      	add s0,a0,a1 # f = g + h
      	add s1,a2,a3 # s1 = i + j
      	sub a0,s0,s1 # return value (g + h) – (i + j)

      	lw s0, 0(sp) # restore register s0 for caller 
      	lw s1, 4(sp) # restore register s1 for caller
      	addi sp,sp,8 # adjust stack to delete 2 items
      	jr ra 	 # jump back to calling routine
```

## Register Conventions

* CalleR: the calling function&#x20;
* CalleE: the function being called&#x20;
* When callee returns from executing, the caller needs to know which registers may have changed and which are guaranteed to be unchanged.&#x20;
* Register Conventions: A set of generally accepted rules as to which registers will be unchanged after a procedure call (jal) and which may be changed.
* To reduce expensive loads and stores from spilling and restoring registers, RISC-V function-calling convention divides registers into two categories:
  * Preserved across function call
    * Caller can rely on values being unchanged
    * sp, gp, tp, “saved registers” s0- s11 (s0 is also fp)
  * Not preserved across function call
    * Caller cannot rely on values being unchanged
    * Argument/return registers a0-a7, ra, “temporary registers” t0-t6

| Register | ABI Name | Description                       | Saver  |
| -------- | -------- | --------------------------------- | ------ |
| x0       | zero     | Hard-wired zero                   | -      |
| x1       | ra       | Return address                    | Caller |
| x2       | sp       | Stack pointer                     | Callee |
| x3       | gp       | Global pointer                    | -      |
| x4       | tp       | Thread pointer                    | -      |
| x5       | t0       | Temporary/Alternate link register | Caller |
| x6-7     | t1-2     | Temporaries                       | Caller |
| x8       | s0/fp    | Saved register/Frame pointer      | Callee |
| x9       | s1       | Saved register                    | Callee |
| x10-11   | a0-1     | Function arguments/Return values  | Caller |
| x12-17   | a2-7     | Function arguments                | Caller |
| x18-27   | s2-11    | Saved registers                   | Callee |
| x28-31   | t3-6     | Temporaries                       | Caller |



## Conclusion

* Arithmetic/logic
  * add rd, rs1, rs2
  * sub rd, rs1, rs2
  * and rd, rs1, rs2
  * or  rd, rs1, rs2
  * xor rd, rs1, rs2
  * sll rd, rs1, rs2
  * srl rd, rs1, rs2
  * sra rd, rs1, rs2
* Immediate (no subi,)
  * andi rd, rs1, imm
  * ori  rd, rs1, imm
  * xori rd, rs1, imm
  * slli rd, rs1, imm
  * srli rd, rs1, imm
  * srai rd, rs1, imm
* Load/store
  * lw  rd,  rs1, imm
  * lh rd, rs1, imm
  * lb  rd,  rs1, imm
  * lbu rd,  rs1, imm
  * sw  rs1, rs2, imm
  * sb  rs1, rs2, imm
* Branching/jumps
  * beq  rs1, rs2, Label
  * bne  rs1, rs2, Label
  * bge  rs1, rs2, Label
  * blt  rs1, rs2, Label
  * bgeu rs1, rs2, Label
  * bltu rs1, rs2, Label
  * jal  rd, Label
  * jalr rd, rs, imm
