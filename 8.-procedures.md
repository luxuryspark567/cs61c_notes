# 8. Procedures

## RISC-V Instruction Conclusion

* Arithmetic (no subi)
  * add rd, rs1, rs2
  * andi rd, rs1, imm
  * sub rd, rs1, rs2
* Logic (no not)
  * or  rd, rs1, rs2
  * ori  rd, rs1, imm
  * xor rd, rs1, rs2
  * xori rd, rs1, imm
  * not is to use xor with 0xFF
  * Used for ‘masks’&#x20;
    * andi with 0000 00FFhex isolates the least significant byte&#x20;
    * andi with FF00 0000hex isolates the most significant byte
* Logical Shifting (<mark style="color:red;">zero extending</mark>)
  * sll rd, rs1, rs2: Shift Left Logical
  * slli rd, rs1, imm: immediate\
    slli x11,x12,2 #x11=x12<<2&#x20;
  * srl rd, rs1, rs2
  * srli rd, rs1, imm
* Arithmetic Shifting (<mark style="color:red;">sign extending</mark>)
  * srai rd, rs1, imm: Shift right arithmetic (sra, srai) moves n bits to the right (insert high-order sign bit into empty bits)
  * For positive numbers, shift right is the same as divided by 2^n;
  * For nodd negative numbers, shift right is NOT same as dividing by 2^n, because C arithmetic semantics is that division should round towards 0.
* Load & Store (no ‘sbu’)
  * Big- vs Little Endian
    * Tip: draw lowest byte on the right (little)
  * lw  rd,  rs1, imm
    * lw  x10,12(x15)
      * x15 – base register (pointer to A\[0])
      * 12 – offset in bytes
      * Offset must be a constant known at assembly time
  * lh rd, rs1, imm
  * lb  rd,  rs1, imm
    * lb x10,3(x11)&#x20;
    * sign extending: <mark style="color:red;">extend the sign bits to fill register</mark>
    * contents of memory location with address = sum of “3” + contents of register x11 is copied to <mark style="color:red;">the low byte position of</mark> register x10.
  * lbu rd,  rs1, imm
  * sw  rs1, rs2, imm
    * `sw  x10,40(x15)`
      * x15 – base register (pointer)
      * 40 – offsets in bytes
      * x15+40 must be multiples of 4
  * sb  rs1, rs2, imm
* Conditional Branch (No ‘bgt’ or ‘ble’ instructions)
  * beq  rs1, rs2, Label: branch if equal&#x20;
  * bne  rs1, rs2, Label: branch if not equal
  * blt  rs1, rs2, Label: <mark style="color:green;">if (reg1 < reg2) goto Label;</mark>
  * bge  rs1, rs2, Label: branch if greater than or equal&#x20;
  * unsigned versions: bltu rs1, rs2, Label`,`bgeu rs1, rs2, Label
* Unconditional Branch – always branch&#x20;
  * <mark style="color:yellow;">**jal  rd, Label**</mark> – jump-and-link # rd = pc+4; pc += imm
  * <mark style="color:yellow;">**jalr rd, rs, imm**</mark> – jump-and-link register # rd = pc+4; pc = R\[rs1]+imm
    * As we’re going to see, “ain’t no free lunch”, so there might not be enough bits left for the Label to go as far as we want to jump.
    * With jalr, we jump to the contents of the register rs + immediate imm (like a base pointer and offset) and set rd as in jal
  * <mark style="color:yellow;">**j**</mark>, <mark style="color:yellow;">**jr**</mark> and <mark style="color:yellow;">**ret**</mark> are <mark style="color:red;">pseudoinstructions</mark>!
    * j:   jal  x0, Label
    * jr ra: Unconditional jump to address specified in register
    * <mark style="color:yellow;">**ret = jr ra**</mark>

## Six Fundamental Steps in Calling a Function

1. Put arguments in a place where function can access them&#x20;
2. Transfer control to function&#x20;
3. Acquire (local) storage resources needed for function&#x20;
4. Perform desired task of the function&#x20;
5. Put return value in a place where calling code can access it and restore any registers you used; release local storage&#x20;
6. Return control to point of origin, since a function can be called from several points in a program

## RISC-V Function Call Conventions

* Registers faster than memory
* <mark style="color:yellow;">a0–a7 (x10-x17)</mark>: eight argument registers to pass parameters and two return values (a0-a1)&#x20;
* <mark style="color:yellow;">ra</mark>: one return address register to return to the point of origin (x1)&#x20;
* <mark style="color:yellow;">s0-s1 (x8-x9)</mark> and <mark style="color:yellow;">s2-s11 (x18-x27)</mark>: saved registers (more about those later)

## Function Call Example

```c
int Leaf (int g, int h, int i, int j)
{
		int f;
		f = (g + h) – (i + j);
		return f;
}
/*
Parameter variables g, h, i, and j in 
argument registers a0, a1, a2, and a3, 
and f in s0.
Assume need one temporary register s1
*/
```

```wasm
Leaf: 	addi sp,sp,-8 # adjust stack for 2 items
		sw s1, 4(sp)  # save s1 for use afterwards
      	sw s0, 0(sp)  # save s0 for use afterwards

      	add s0,a0,a1 # f = g + h
      	add s1,a2,a3 # s1 = i + j
      	sub a0,s0,s1 # return value (g + h) – (i + j)

      	lw s0, 0(sp) # restore register s0 for caller 
      	lw s1, 4(sp) # restore register s1 for caller
      	addi sp,sp,8 # adjust stack to delete 2 items
      	jr ra 	 # jump back to calling routine
```

## Register Conventions

* CalleR: the calling function&#x20;
* CalleE: the function being called&#x20;
* When callee returns from executing, the caller needs to know which registers may have changed and which are guaranteed to be unchanged.&#x20;
* Register Conventions: A set of generally accepted rules as to which registers will be unchanged after a procedure call (jal) and which may be changed.
* To reduce expensive loads and stores from spilling and restoring registers, RISC-V function-calling convention divides registers into two categories:
  * Preserved across function call
    * Caller can rely on values being unchanged
    * <mark style="color:yellow;">sp, gp, tp,</mark> <mark style="color:yellow;">“saved registers” s0- s11 (s0 is also fp)</mark>
  * Not preserved across function call
    * Caller cannot rely on values being unchanged
    * Argument/return registers <mark style="color:yellow;">a0-a7, ra, “temporary registers” t0-t6</mark>

| Register | ABI Name | Description                       | Saver  |
| -------- | -------- | --------------------------------- | ------ |
| x0       | zero     | Hard-wired zero                   | -      |
| x1       | ra       | Return address                    | Caller |
| x2       | sp       | Stack pointer                     | Callee |
| x3       | gp       | Global pointer                    | -      |
| x4       | tp       | Thread pointer                    | -      |
| x5       | t0       | Temporary/Alternate link register | Caller |
| x6-7     | t1-2     | Temporaries                       | Caller |
| x8       | s0/fp    | Saved register/Frame pointer      | Callee |
| x9       | s1       | Saved register                    | Callee |
| x10-11   | a0-1     | Function arguments/Return values  | Caller |
| x12-17   | a2-7     | Function arguments                | Caller |
| x18-27   | s2-11    | Saved registers                   | Callee |
| x28-31   | t3-6     | Temporaries                       | Caller |

## Example

### if Statement

Assuming translations below, compile if block

&#x20;f → x10; g → x11; h → x12;  i → x13; j → x14;

```c
if (i == j)  
  f = g + h;
```

```wasm
bne x13,x14,Exit
add x10,x11,x12
Exit:
```

### if-else Statement

Assuming translations below, compile

&#x20; f → x10  g → x11    h → x12  i → x13    j → x14

```c
if (i == j)
    f = g + h; 
else
    f = g – h;
```

```wasm
bne x13,x14,Else 
add x10,x11,x12 
j Exit 
Else:sub x10,x11,x12
Exit: 
```

### Loops in C/Assembly

```
int A[20];
// fill A with data
int sum = 0;
for (int i=0; i < 20; i++)
    sum += A[i];
```

```wasm
  add x9, x8, x0 # x9=&A[0]
  add x10, x0, x0 # sum=0
  add x11, x0, x0 # i = 0
  addi x13,x0, 20 # x13 = 20
Loop:
  bge x11,x13,Done
  lw x12, 0(x9)   # x12=A[i]
  add x10,x10,x12 # sum+=x12
  addi x9, x9,4   # &A[i+1]
  addi x11,x11,1  # i++
  j Loop
Done:  
```
