# 18. Arithmetic/Logical Datapath

## Build a Single-Core Processor

Datapath (“the brawn”): portion of the processor that contains hardware necessary to perform operations required by the processor.&#x20;

Control (“the brain”): portion of the processor (also in hardware) that tells the datapath what needs to be done.

<figure><img src=".gitbook/assets/image (142).png" alt=""><figcaption></figcaption></figure>

## Combinational Logic Blocks

<figure><img src=".gitbook/assets/image (143).png" alt=""><figcaption></figcaption></figure>

The CPU is composed of two types of subcircuits: combinational logic blocks and state elements.

* On every tick of the clock, the computer executes one instruction:
  * Current outputs of the state elements drive the inputs to combinational logic…
  * …whose outputs settle at the inputs to the state elements before the next rising clock edge.
* At the rising clock edge:
  * All the state elements are updated with the combinational logic outputs…
  * and execution moves to the next clock cycle.

## Program Counter

<figure><img src=".gitbook/assets/image (144).png" alt="" width="179"><figcaption></figcaption></figure>

The Program Counter is a 32-bit Register.

* Input:
  * N-bit data input bus
  * Write Enable “Control” bit (1: asserted/high, 0: deasserted/0)
* Output:
  * N-bit data output bus
* Behavior:
  * If Write Enable is 1 on rising clock edge, set Data Out=Data In.
  * At all other times, Data Out will not change; it will output its current value.

## Register File

<figure><img src=".gitbook/assets/image (145).png" alt="" width="188"><figcaption></figcaption></figure>

Register File (RegFile) has 32 registers.

* Input:
  * One 32-bit input data bus, dataW.
  * Three 5-bit select busses, rs1, rs2, and rsW.
  * RegWEn control bit.
* Output:
  * Two 32-bit output data busses, data1 and data2.
* Registers are accessed via their 5-bit register numbers:&#x20;
  * R\[rs1]: rs1 selects register to put on data1 bus out.&#x20;
  * R\[rs2]: rs2 selects register to put on data2 bus out.
  * R\[rd]: rsW selects register to be written via dataW when RegWEn=1.&#x20;
* Clock behavior: Write operation occurs on rising clock edge.&#x20;
  * Clock input only a factor on write!&#x20;
  * All read operations behave like a combinational block: If rs1, rs2 valid, then data1, data2 valid after access time.

{% hint style="info" %}
RegFile behaves like a combinational block for read operations!
{% endhint %}

## Memory

<figure><img src=".gitbook/assets/image (147).png" alt=""><figcaption></figcaption></figure>

Memory is “magic.” For this class:

* 32-bit byte-addressed memory space; and
* Memory access with 32-bit words.
* Memory words are accessed as follows:&#x20;
  * Read: Address addr selects word to put on dataR bus.&#x20;
  * Write: Set MemRW=1. Address addr selects word to be written with dataW bus.&#x20;
* Like RegFile, clock input is only a factor on write.&#x20;
  * If MemRW=1, write occurs on rising clock edge.&#x20;
  * If MemRW=0 and addr valid, then dataR valid after access time.

{% hint style="info" %}
If MemRW=0, MEM behaves like a combinational block.
{% endhint %}

* Current abstraction: Memory holds both instructions and data in one contiguous 32-bit memory space.&#x20;
* In our processor, we’ll use two “separate” memories:&#x20;
  * IMEM: A read-only memory for fetching instructions.&#x20;
  * DMEM: A memory for loading (read) and storing (write) data words.&#x20;
  * Under the hood, these are placeholders for caches. (more later)&#x20;
* Because IMEM is read-only, it always behaves like a combinational block:&#x20;
  * If addr valid, then instr valid after access time.

## Design the Datapath in Phases

* Smaller stages are easier to design!&#x20;
* Modularity: Easy to optimize one stage without touching the others.

5 Basic Stages (Phases) of Instruction Execution





## R-Type: add datapath

add rd, rs1, rs2

<figure><img src=".gitbook/assets/image (148).png" alt=""><figcaption></figcaption></figure>

* The add instruction makes two changes to processor state:&#x20;
  * RegFile R\[rd] = R\[rs1] + R\[rs2]&#x20;
  * PC PC = PC + 4

<figure><img src=".gitbook/assets/image (149).png" alt=""><figcaption></figcaption></figure>

## R-Type: sub datapath

sub rd, rs1, rs2

<figure><img src=".gitbook/assets/image (150).png" alt=""><figcaption></figcaption></figure>

* sub is almost the same as add, except now the ALU subtracts operands instead of adding them:
  * RegFile  R\[rd] = R\[rs1] - R\[rs2]
  * PC  PC = PC + 4
* Instruction bit inst\[30] selects between add/sub.
  * Details left to control logic.

<figure><img src=".gitbook/assets/image (151).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Control and Datapath are two abstractions that together comprise the CPU. Under the hood, both are designed with combinational logic and/or state elements.
{% endhint %}

<figure><img src=".gitbook/assets/image (152).png" alt=""><figcaption></figcaption></figure>

The Control Logic decodes funct3, funct7 instruction fields and selects appropriate ALU function by setting the control line ALUSel.

<figure><img src=".gitbook/assets/image (153).png" alt="" width="151"><figcaption></figcaption></figure>



## Datapath with immediates: addi

addi rd, rs1, imm

<figure><img src=".gitbook/assets/image (154).png" alt=""><figcaption></figcaption></figure>



* The addi instruction updates the same two states as before. But we now need to build an immediate imm!&#x20;
  * RegFile Reg\[rd] = Reg\[rs1] + imm&#x20;
  * PC PC = PC + 4

we should feed in an immediate to ALU input B (instead of R\[rs2]).

<figure><img src=".gitbook/assets/image (155).png" alt=""><figcaption></figcaption></figure>

## Immediate Generation Block Design

<figure><img src=".gitbook/assets/image (156).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (157).png" alt=""><figcaption></figcaption></figure>

