# 10. RISC-V and Assembly

## RISC-V Instruction Conclusion

* Arithmetic (no <mark style="color:orange;">subi</mark>)
  * <mark style="color:yellow;">add</mark> rd, rs1, rs2
  * <mark style="color:yellow;">andi</mark> rd, rs1, imm
  * <mark style="color:yellow;">sub</mark> rd, rs1, rs2
* Logic (no <mark style="color:orange;">not</mark>)
  * <mark style="color:yellow;">or</mark>  rd, rs1, rs2
  * <mark style="color:yellow;">ori</mark>  rd, rs1, imm
  * <mark style="color:yellow;">xor</mark> rd, rs1, rs2
  * <mark style="color:yellow;">xori</mark> rd, rs1, imm
  * not is to use <mark style="color:red;">xor with 0xFF</mark>
  * Used for ‘masks’&#x20;
    * andi with 0000 00FFhex isolates the least significant byte&#x20;
    * andi with FF00 0000hex isolates the most significant byte
* Logical Shifting (<mark style="color:red;">zero extending</mark>)
  * <mark style="color:yellow;">sll</mark> rd, rs1, rs2: Shift Left Logical
  * <mark style="color:yellow;">slli</mark> rd, rs1, imm: immediate\
    slli x11,x12,2 #x11=x12<<2&#x20;
  * <mark style="color:yellow;">srl</mark> rd, rs1, rs2
  * <mark style="color:yellow;">srli</mark> rd, rs1, imm
* Arithmetic Shifting (<mark style="color:red;">sign extending</mark>)
  * <mark style="color:yellow;">sra</mark> rd, rs1, rs2: Shift right arithmetic
  * <mark style="color:yellow;">srai</mark> rd, rs1, imm: Shift right arithmetic (sra, srai) moves n bits to the right (<mark style="color:red;">insert high-order sign bit into empty bits</mark>)
  * For positive numbers, shift right is the same as divided by 2^n;
  * For odd negative numbers, shift right is NOT same as dividing by 2^n, because C arithmetic semantics is that division should round towards 0.
* Load & Store (no ‘sbu’)
  * Big- vs Little Endian
    * Tip: draw lowest byte on the right (little)
  * <mark style="color:yellow;">lw</mark>  rd,  rs1, imm
    * lw  x10,12(x15)
      * x15 – base register (pointer to A\[0])
      * <mark style="color:red;">12 – offset in bytes</mark>
      * Offset must be a constant known at assembly time
  * <mark style="color:yellow;">lh</mark> rd, rs1, imm
  * <mark style="color:yellow;">lb</mark>  rd,  rs1, imm
    * lb x10,3(x11)&#x20;
    * sign extending: <mark style="color:red;">extend the sign bits to fill register</mark>
    * contents of memory location with address = sum of “3” + contents of register x11 is copied to <mark style="color:red;">the low byte position of</mark> register x10.
  * <mark style="color:yellow;">lbu</mark> rd,  rs1, imm
  * <mark style="color:yellow;">sw</mark>  rs1, rs2, imm
    * `sw  x10,40(x15)`
      * x15 – base register (pointer)
      * 40 – offsets in bytes
      * x15+40 must be multiples of 4
  * <mark style="color:yellow;">sb</mark>  rs1, rs2, imm
* Conditional Branch (<mark style="color:orange;">No ‘bgt’ or ‘ble’ instructions</mark>)
  * <mark style="color:yellow;">beq</mark>  rs1, rs2, Label: branch if equal&#x20;
  * <mark style="color:yellow;">bne</mark>  rs1, rs2, Label: branch if not equal
  * <mark style="color:yellow;">blt</mark>  rs1, rs2, Label: brach if less than, <mark style="color:green;">if (reg1 < reg2) goto Label;</mark>
  * <mark style="color:yellow;">bge</mark>  rs1, rs2, Label: branch if greater than or equal&#x20;
  * unsigned versions: bltu rs1, rs2, Label`,`bgeu rs1, rs2, Label
* Unconditional Branch – always branch&#x20;
  * <mark style="color:yellow;">**jal  rd, Label**</mark> – jump-and-link # rd = pc+4; pc += imm
  * <mark style="color:yellow;">**jalr rd, rs, imm**</mark> – jump-and-link register # rd = pc+4; pc = R\[rs1]+imm
    * As we’re going to see, “ain’t no free lunch”, so there might not be enough bits left for the Label to go as far as we want to jump.
    * With jalr, we jump to the contents of the register <mark style="color:red;">rs + immediate imm</mark> (like <mark style="color:red;">a base pointer and offset</mark>) and set rd as in jal
  * <mark style="color:yellow;">**j**</mark>, <mark style="color:yellow;">**jr**</mark> and <mark style="color:yellow;">**ret**</mark> are <mark style="color:red;">pseudoinstructions</mark>!
    * <mark style="color:yellow;">j</mark>:   jal  x0, Label
    * <mark style="color:yellow;">jr ra</mark>: Unconditional jump to address specified in register
    * <mark style="color:yellow;">**ret = jr ra**</mark>

## Six Fundamental Steps in Calling a Function

1. Put arguments in a place where function can access them&#x20;
2. Transfer control to function&#x20;
3. Acquire (local) storage resources needed for function&#x20;
4. Perform desired task of the function&#x20;
5. Put return value in a place where calling code can access it and restore any registers you used; release local storage&#x20;
6. Return control to point of origin, since a function can be called from several points in a program

## RISC-V Function Call Conventions

* Registers faster than memory
* <mark style="color:yellow;">a0–a7 (x10-x17)</mark>: eight argument registers to pass parameters and two return values (a0-a1)&#x20;
* <mark style="color:yellow;">ra</mark>: one return address register to return to the point of origin (x1)&#x20;
* <mark style="color:yellow;">s0-s1 (x8-x9)</mark> and <mark style="color:yellow;">s2-s11 (x18-x27)</mark>: saved registers (more about those later)

## Function Call Example

Below is not the actual application, is just to show that how to call a function and return in a instinct way.

```c
int Leaf (int g, int h, int i, int j)
{
		int f;
		f = (g + h) – (i + j);
		return f;
}
/*
Parameter variables g, h, i, and j in 
argument registers a0, a1, a2, and a3, 
and f in s0.
Assume need one temporary register s1
*/
```

```wasm
Leaf: 	addi sp,sp,-8 # adjust stack for 2 items
	sw s1, 4(sp)  # save s1 for use afterwards
      	sw s0, 0(sp)  # save s0 for use afterwards

      	add s0,a0,a1 # f = g + h
      	add s1,a2,a3 # s1 = i + j
      	sub a0,s0,s1 # return value (g + h) – (i + j)

      	lw s0, 0(sp) # restore register s0 for caller 
      	lw s1, 4(sp) # restore register s1 for caller
      	addi sp,sp,8 # adjust stack to delete 2 items
      	jr ra 	 # jump back to calling routine
```

## Register Conventions

* CalleR: the calling function&#x20;
* CalleE: the function being called&#x20;
* When callee returns from executing, the caller needs to know which registers may have changed and which are guaranteed to be unchanged.&#x20;
* Register Conventions: A set of generally accepted rules as to which registers will be unchanged after a procedure call (jal) and which may be changed.
* To reduce expensive loads and stores from spilling and restoring registers, RISC-V function-calling convention divides registers into two categories:
  * <mark style="color:red;">Preserved</mark> across function call
    * Caller can rely on values being unchanged
    * <mark style="color:yellow;">sp, gp, tp,</mark> <mark style="color:yellow;">“saved registers” s0- s11 (s0 is also fp)</mark>
  * <mark style="color:red;">Not preserved</mark> across function call
    * Caller cannot rely on values being unchanged
    * Argument/return registers <mark style="color:yellow;">a0-a7, ra, “temporary registers” t0-t6</mark>

| Register | ABI Name | Description                       | Saver                                     |
| -------- | -------- | --------------------------------- | ----------------------------------------- |
| x0       | zero     | Hard-wired zero                   | -                                         |
| x1       | ra       | Return address                    | Caller                                    |
| x2       | sp       | Stack pointer                     | <mark style="color:yellow;">Callee</mark> |
| x3       | gp       | Global pointer                    | -                                         |
| x4       | tp       | Thread pointer                    | -                                         |
| x5       | t0       | Temporary/Alternate link register | Caller                                    |
| x6-7     | t1-2     | Temporaries                       | Caller                                    |
| x8       | s0/fp    | Saved register/Frame pointer      | <mark style="color:yellow;">Callee</mark> |
| x9       | s1       | Saved register                    | <mark style="color:yellow;">Callee</mark> |
| x10-11   | a0-1     | Function arguments/Return values  | Caller                                    |
| x12-17   | a2-7     | Function arguments                | Caller                                    |
| x18-27   | s2-11    | Saved registers                   | <mark style="color:yellow;">Callee</mark> |
| x28-31   | t3-6     | Temporaries                       | Caller                                    |

## Example

### if Statement

Assuming translations below, compile if block

&#x20;f → x10; g → x11; h → x12;  i → x13; j → x14;

```c
if (i == j)  
  f = g + h;
```

```wasm
bne x13,x14,Exit
add x10,x11,x12
Exit:
```

### if-else Statement

Assuming translations below, compile

&#x20; f → x10  g → x11    h → x12  i → x13    j → x14

```c
if (i == j)
    f = g + h; 
else
    f = g – h;
```

```wasm
bne x13,x14,Else 
add x10,x11,x12 
j Exit 
Else:sub x10,x11,x12
Exit: 
```

### Loops in C/Assembly

```
int A[20];
// fill A with data
int sum = 0;
for (int i=0; i < 20; i++)
    sum += A[i];
```

```wasm
  add x9, x8, x0 # x9=&A[0]
  add x10, x0, x0 # sum=0
  add x11, x0, x0 # i = 0
  addi x13,x0, 20 # x13 = 20
Loop:
  bge x11,x13,Done
  lw x12, 0(x9)   # x12=A[i]
  add x10,x10,x12 # sum+=x12
  addi x9, x9,4   # &A[i+1]
  addi x11,x11,1  # i++
  j Loop
Done:  
```
