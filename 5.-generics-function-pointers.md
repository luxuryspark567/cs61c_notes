# 5. Generics Function Pointers

* Function pointers enable **higher-order functions** in C.&#x20;
  * map, filter, sorting, etc.&#x20;
    * Define: <mark style="color:red;">`int(*fp)(int)`</mark>
    * Call:`(`<mark style="color:red;">`*fp`</mark>`)(...);`
    * Assign:`fp =`<mark style="color:red;">`&`</mark>`multiply;`
  *   <mark style="color:red;">**Dereferencing or referencing**</mark> <mark style="color:red;"></mark><mark style="color:red;">of</mark> <mark style="color:red;"></mark><mark style="color:red;">**a function name**</mark> <mark style="color:red;"></mark><mark style="color:red;">just evaluates to</mark> <mark style="color:red;"></mark><mark style="color:red;">**a pointer to that function.**</mark> This behavior is (thus obviously) very different from how the unary `&` and `*` operators works for normal variables.

      So,

      ```c
      test2 = myprint;
      test2 = &myprint;
      test2 = *myprint;
      test2 = **********myprint;
      ```

      All just do exactly the same, gives you a function pointer to `myprint`
  *   <mark style="color:red;">**Dereferencing**</mark> <mark style="color:red;"></mark><mark style="color:red;">a</mark> <mark style="color:red;"></mark><mark style="color:red;">**function pointer**</mark> <mark style="color:red;">evaluates back to the function pointer</mark>.\


      <pre class="language-c"><code class="lang-c"><strong>test2(s);
      </strong>(*test2)(s);
      (***********test2)(s);
      </code></pre>

      Does the same, call the function pointer stored in `test2`. Because C says it does.
  * Referencing a function point is the same as normal pointer operations.

{% hint style="info" %}
[https://stackoverflow.com/questions/7518815/function-pointer-automatic-dereferencing](https://stackoverflow.com/questions/7518815/function-pointer-automatic-dereferencing)
{% endhint %}

* Generic functions (i.e., generics), use `void *` pointers to operate on memory.&#x20;
  * Generics are widely present in the C standard library (malloc, memcpy, qsort, …)&#x20;
    * <mark style="color:red;">memcpy</mark>: memory areas <mark style="color:red;">**MUST NOT**</mark> <mark style="color:red;"></mark><mark style="color:red;">overlap</mark>
    * <mark style="color:red;">`memmove`</mark>`:`Memory areas <mark style="color:red;">MIGHT overlap</mark>, and slow for temporary storage, and risks running out of memory.
  * Generics require a solid understanding of memory! By manipulating arbitrary bytes, you <mark style="color:red;">risk violating data boundaries</mark>, e.g., “Frankenstein”-ing two halves of ints.&#x20;

> ▪Not only is memcpy faster, but some implementations of memmove actually employ temporary storage (like in C99), which risks running out of memory. \[[source1](https://clc-wiki.net/wiki/memmove), [source2](https://stackoverflow.com/questions/4415910/memcpy-vs-memmove)]
>
> “copying takes place <mark style="color:yellow;">as though</mark> the bytes in src are first copied into <mark style="color:yellow;">a temporary array</mark> … then copied … to dest.”

* Reminders when writing generics:&#x20;
  * <mark style="color:red;">Generic pointers do</mark> <mark style="color:red;"></mark><mark style="color:red;">**not support dereferencing**</mark>, as the number of bytes to access from memory is not known at compile-time.&#x20;
  * Instead, use <mark style="color:red;">byte</mark> handling functions (memcpy, memmove).&#x20;
  * Pointer arithmetic: <mark style="color:red;">cast to byte arrays with</mark> <mark style="color:red;"></mark><mark style="color:red;">`(char *)`</mark><mark style="color:red;">first</mark>.
