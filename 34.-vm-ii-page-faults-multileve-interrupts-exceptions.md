# 34. VM II  Page Faults, Multileve, Interrupts Exceptions

## Virtual Memory: Page Tables

* Each process has a dedicated page table.
  * OS keeps track of which process is active.
* Isolation: Assign processes different pages in DRAM
  * ﻿﻿Prevents (protects) a process from accessing other processes' data
  * ﻿﻿Page tables managed by OS

## Page Tables Are Stored in Memory

* ﻿﻿If 32-Bit virtual address space, 4 GiB DRAM, 4-KiB pages:
  * ﻿﻿# page table entries = # Virtual Page Numbers = 232 / 212 = 220
  * ﻿﻿Suppose each page table entry = 4 B (PPN + status bits).
  * ﻿﻿Page Table Size: 4 MiB = 0.1% DRAM. Not bad...
    * ﻿﻿But much too large for a cache!
* ﻿﻿For now, store page tables in memory (DRAM).
  * ﻿﻿Caveat: Two (slow) memory accesses per Iw/ sw on cache miss!

## Page Tables Are Stored in Memory

* Caveat: 1w/ sw then requires two memory accesses:
  * Read page table (stored in main memory) to translate to physical address.
  * Read physical page, also in main memory.
* To minimize the performance penalty:
  * Transfer blocks (not words) between DRAM and processor cache.
  * Use a cache for frequently used page antraltable entries... (more later, TLB)

## Page Faults

* ﻿﻿Page table entries store status to indicate if the page is in memory (DRAM) or only on disk.
  * ﻿﻿On each memory access, check the page table entry "valid" status bit.
* ﻿﻿Valid → In DRAM
  * ﻿﻿Read/write data in DRAM
* ﻿﻿Not Valid → On disk
  * ﻿﻿Triggers a Page Fault, OS intervenes to allocate the page into DRAM.
  * ﻿﻿If out of memory, first evict a page from DRAM.
  * ﻿﻿Store evicted page to disk.
  * Read requested page from disk into DRAM.
  * Finally, read/write data in DRAM.

The page replacement policy (e.g., LRU/FIFO/random) is usually done in OS/software; this overheard << disk access time.

## Page Table Metadata: Status Bits

* ﻿﻿Write Protection Bit
  * ﻿﻿On: If process writes to page, trigger exception
* ﻿﻿Valid Bit
  * ﻿﻿On: Page is in RAM
* ﻿﻿Dirty Bit
  * ﻿﻿On: Page on RAM is more up-to-date than page on disk

<figure><img src=".gitbook/assets/image (26).png" alt="" width="375"><figcaption></figcaption></figure>

## Memory's Write Policy?

* ﻿﻿DRAM acts like a "cache" for disk.
  * ﻿﻿Should writes always go directly to disk (write-through), or
  * ﻿﻿Should writes only go to disk when page is evicted (write-back)?
* ﻿﻿Answer: All virtual memory systems use write-back.
  * ﻿﻿Disk accesses take too long!

## Page Tables Are Stored in Memory!

* ﻿﻿If 32-bit virtual address space, 4 GiB RAM, 4-KiB pages:
  * ﻿﻿# page table entries = # Virtual Page Numbers = 232 / 212 = 220
  * ﻿﻿Suppose each page table entry = 4 B (PPN + status bits).
  * ﻿﻿Page Table Size: 4 MiB → 0.1% RAM. Not bad...
* ﻿﻿...except each program needs its own page table.
* ﻿﻿If we have 256 processes:
  * ﻿﻿256 × 4 MiB = 2^8 • 2^2 • 2^20 = 1 GiB → 25% RAM just for page tables!
* ﻿﻿Complication: page tables must be in RAM to be accessed.
  * ﻿﻿Can't swap out entire page table to disk...

## Enter the Page Table Hierarchy

* ﻿﻿What if we page tabled our page tables?
* Multilevel page tables with decreasing page size:
  * ﻿﻿Key insight: Sparsity of Virtual Address Space use.
    * ﻿﻿Most program use a fraction of virtual memory, so many page table entries are not accessed.
  * ﻿﻿Level 1 page table always in DRAM.
  * ﻿﻿Level 2 page tables can be in disk; loaded into DRAM via Level 1 access.

## Multilevel Page Table Translation

* ﻿﻿32-bit virtual address space, 4 GiB DRAM, 4-KiB pages:
  * ﻿﻿Page table entry size is 4 B for all levels of page tables.
  * ﻿﻿RV32| 2-level mapping:

<figure><img src=".gitbook/assets/image (32).png" alt=""><figcaption></figcaption></figure>

## 1-Level vs. 2-Level Page Tables

* ﻿﻿32-bit computer (virtual address space), 4 GiB DRAM, 4-KiB pages.
* ﻿﻿Page table entry size is 4 B for all levels of page tables.
* ﻿﻿Suppose we run 16 processes.

1. How much RAM is consumed by page tables if we have only one level of page table?
   1. Page offset: log(page size) = log(4KiB) = log(2^12) = 12&#x20;
   2. ﻿﻿# entries in page table = # VPNs = 2^32/2^12=2^20
   3. Page table size = 2^20 x (4 B) = 2^22 B
   4. ﻿﻿Total RAM consumed = (16 processes) x 2^22 B = 64 MiB
2. How much RAM is consumed by Level 1 if we we use the two-level hierarchy from the previous slide?
   1. \# entries in Level 1 PT (= # Level 2 PTs) = 2^10
   2. Page table size = 2^10 x (4 B) = 2^12 B
   3. Total RAM consumed = (16 processes) x 2^12 B = 64 KiB

<figure><img src=".gitbook/assets/image (284).png" alt="" width="375"><figcaption></figcaption></figure>

## Multilevel Page Table Translation Demo

* ﻿﻿32-bit virtual address space, 4 GiB DRAM, 4-KiB pages:
  * ﻿﻿RV32| 2-level mapping:

<figure><img src=".gitbook/assets/image (285).png" alt=""><figcaption></figcaption></figure>

Q: How does the OS manage Virtual Memory (e.g., page faults)?

A: Exceptions!

## Supervisor Mode v.s. User, Mode

* ﻿﻿If an application goes wrong (or rogue, e.g., malware), it could crash the entire machine!
* ﻿﻿CPUs have a hardware supervisor mode (i.e., kernel mode).
  * ﻿﻿Set by a status bit in a special register.
  * ﻿﻿An OS process in supervisor mode helps enforce constraints to other processes, e.g., access to memory, devices, etc.
  * ﻿﻿Supervisor mode is a bit like "superuser"...
    * ﻿﻿Errors in supervisory mode are often catastrophic (blue "screen of death", or "I just corrupted your disk")
* ﻿﻿By contrast, in user mode, a process can only access a subset of instructions and (physical) memory.
  * ﻿﻿Can change out of supervisor mode using a special instruction (e.g. sret).
  * ﻿﻿Cannot change into supervisor mode directly; instead, HW interrupt/exception.
  * The OS mostly runs in user mode! Supervisor mode is used sparingly.

## Exceptions and Intertints.

1. Exceptions
   1. Caused by an event during the execution of the current program.
   2. Synchronous, must be handled immediately:
   3.  Examples:

       1. Illegal instruction
       2. Divide by zero
       3. ﻿﻿Page fault
       4. ﻿﻿Write protection violation


2. Interrupts (more later)
   1. Caused by an event externa/to the current running program.
   2. Asynchronousto current program; does not need to be handled immediately (but should be soon).
   3. Examples:
      1. Key press
      2. Disk I/O

## Traps Handle Exreptinne/interrupts

* The trap handler is code that services interrupts/exceptions.
  * Complete all instructions before the faulting instruction.
  * Flush all instructions after the faulting instruction.
    * ﻿﻿Like pipeline hazard: convert to noops/"bubbles."
    * Also flush faulting instruction.
  * Transfer execution to trap handler (runs in supervisor mode).
    * Optionally return to original program and re-execute instruction.

If the trap handler returns, then from the program's point of view it must look like nothing has happened!
