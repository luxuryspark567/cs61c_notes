# 什么时候使用a, s, t寄存器



* 如果当前函数中使用了s寄存器，在函数头要执行push \[s] & push \[ra]，函数结尾执行pop；
* 如果当前函数中用了t，在调用其他函数的前后，就要push\[t]和pop \[t]；
* a进行参数传递，在调用其他函数前，将参数放到a；函数执行完毕后，将返回值写到a。

在汇编语言中，`s`、`t` 和 `a` 寄存器分别用于不同的场景，主要根据数据的作用范围、生命周期以及调用函数的需求。下面是详细的说明和每种情况的例子：

#### 1. **`s` 寄存器**（Saved Registers）

* **使用场景**：用于保存需要在函数调用之间保持的数据，函数调用结束后值仍需保留。典型场景是全局变量或局部变量的持久保存。例如f0调用了f1、f2和f3，如果变量存储在s，则在f1、f2和f3调用的时候，都不需要将变量push到stack；如果是放在t变量，就需要执行push stack。
* **存储责任**：被调用者（callee）负责保存和恢复这些寄存器的值。
*   **例子**：在一个递归函数中存储一个计数器，递归返回时需要恢复之前的值。

    ```assembly
    assemblyCopy code# 假设函数使用$s0存储递归计数器
    my_function:
        addi $s0, $s0, 1    # 计数器递增
        jal recursive_call   # 调用递归函数
        sub $s0, $s0, 1      # 递归结束后恢复计数器
        jr $ra
    ```

#### 2. **`t` 寄存器**（Temporary Registers）

* **使用场景**：用于临时存储只在当前函数内使用的数据或计算结果。它们不会在函数调用后保留，因此非常适合临时运算或短期数据。
* **存储责任**：`t` 寄存器无需保存，调用者（caller）不必担心它们的值会在函数调用中被改变。
*   **例子**：在一个循环中进行简单的加法运算，使用`t`寄存器来保存临时的计算结果。

    ```assembly
    assemblyCopy code# 使用临时寄存器$t0存储中间值
    loop:
        add $t0, $t1, $t2    # 将$t1和$t2相加，结果存在$t0
        beq $t0, $zero, exit # 如果$t0为0，则跳出循环
        j loop
    ```

#### 3. **`a` 寄存器**（Argument Registers）

* **使用场景**：用于函数参数传递和返回值的传递。函数参数通过 `a` 寄存器传递给被调用函数，调用函数可以直接使用这些寄存器来获取参数。
* **存储责任**：调用者（caller）负责将参数传递到 `a` 寄存器中，且这些寄存器的值在函数调用中可能会被覆盖。
*   **例子**：将两个参数传递给函数，使用 `a0` 和 `a1` 传递函数参数，并调用函数。

    ```assembly
    assemblyCopy code# 调用函数之前，把参数存入a寄存器
    li $a0, 5            # 参数1
    li $a1, 10           # 参数2
    jal sum_function     # 跳转到函数sum_function

    # 在sum_function中，使用a寄存器中的值
    sum_function:
        add $v0, $a0, $a1  # 返回a0和a1的和
        jr $ra             # 返回调用者
    ```

#### 总结：

* **`s` 寄存器**：用于需要跨越函数调用保存的数据，典型场景为递归、全局变量等（被调用者保存）。
* **`t` 寄存器**：用于临时数据和中间计算，仅在当前函数内使用（不需保存）。
* **`a` 寄存器**：用于传递函数参数和返回值，适用于函数调用场景（由调用者传递和使用）。
