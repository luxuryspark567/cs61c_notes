# 35. TLB

Exceptions in a 5-Stage Pipeline

* ﻿﻿Traps are handled similarly to pipeline hazards.
* ﻿﻿In RISC-V, the exception cause can be inferred by the faulting instruction and its current pipeline stage.

IF

ID

EX

MEM

WB

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

The Trap Handler

1\. Save the state of the current program.

• Save ALL of the registers!

1. ﻿﻿﻿Determine what caused the exception/interrupt.
2. ﻿﻿﻿Handle exception/interrupt, then do one of two things:

Program

Handler

Lisa Yan

Continue execution of the program:

1. ﻿﻿﻿Restore program state.
2. ﻿﻿﻿Return control to the program.

lexcep-1

ho

Чехсер

h1

Terminate the program:

1. ﻿﻿﻿Free the program resources, etc.
2. ﻿﻿﻿Schedule a new program.

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Handling Context Switches

• Recall the context switch:

Lisa Yan

* ﻿﻿OS switches between processes (i.e., programs) by changing the internal state of the processor.
* ﻿﻿Allows a single processor to "simultaneously" run many programs.
* ﻿﻿At a high-level:
* ﻿﻿The OS sets a timer. When it expires, perform a hardware interrupt.
* ﻿﻿Trap handler saves all register values, including:
* ﻿﻿Program Counter (PC)
* ﻿﻿Page Table Register (SPTBR in RV321)
* ﻿﻿The memory address of the active process's page table.
* ﻿﻿Trap handler then loads in the next process's registers and returns to user mode.

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

Handling Page Fa

• Recall page faults:

Lisa Yan

* ﻿﻿An accessed page table entry has valid bit off → data is not in DRAM.
* ﻿﻿Page faults are handled by the trap handler.
* ﻿﻿The page fault exception handler initiates transfers to/from disk and ‹ performs any page table updates.
* ﻿﻿(If pages needs to be swapped from disk, perform context switch so that another process can use the CPU in the meantime.)
* ﻿﻿ideally need a "precise trap" so that resuming a process is easy.)
* ﻿﻿Following the page fault, re-execute the instruction.
* ﻿﻿Side note: Write protection violations also trigger exceptions.

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

System Calls and Launching Applications

* ﻿﻿A system call (syscall) is a "software interrupt" that allows a program to request a service from the operating system.
* ﻿﻿Similar to a function call, except now executed by kernel.
* ﻿﻿Examples:
* ﻿﻿Creating and deleting files; reading/writing files;
* ﻿﻿Accessing external devices (e.g., scanner);

Lisa Yan

* ﻿﻿printf, malloc, etc. (ecalls in RISC-V); etc.
* ﻿﻿Launch a new process
* ﻿﻿Suppose shell (a user process) wants to launch a new app:
* ﻿﻿Shell forks (in Linux): a syscall that traps into the OS kernel process
* ﻿﻿OS (supervisor mode): Load program (see CALL); jump to start of main.\
  Return to user mode.
* ﻿﻿Shell: "wait" for main to return (join)

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

[https://youtu.be/1mz-ztcwbZk](https://youtu.be/1mz-ztcwbZk)

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

What Happens at Boot? (2/2)

• Then, the BIOS (Basic Input Output System) firmware loads the bootloader, which loads the OS kernel.

1\. BIOS: Find a

3\. OS Boot. Initialize

wicmn

storage

services, drivers,

device and load

Lisa Yan

the first sector (block of data).

2\. Bootloader.

(stored on, e.g., disk)

Load the OS kernel from disk into a location in memory

4\. Init. Launch an application (e.g.,

Terminal/Desktop/...) that waits for input in loop.

and jump into it.

<figure><img src=".gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Caches vs. Primary Memory

* ﻿﻿Blocks, pages, (bytes, words) are all units of memory.
* ﻿﻿Caches: blocks

• Memory: pages

• On modern systems, \~64B.

• On modern systems, \~4KiB.

<figure><img src=".gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

Caches vs. Page Tables

"Cache" Paradigm: Data at each level is a quick-access copy of data at a lower level in the memory hierarchy.

<figure><img src=".gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

Caches vs. Page Tables

* ﻿﻿A Page Table translates addresses.
* ﻿﻿Page tables store physical page numbers, not data.

(assuming single-level page tables)

• Page tables facilitate

DRAM (primary memory)

Demand Paging.

Page Table

Valid

PPN

<

\- Cache data pages in

1

memory.

…

0

• Access disk pages only when needed by the

Data Page

process.

• Page Table keeps track of page status/location.

<figure><img src=".gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

Caching vs. Demand Paging

<figure><img src=".gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

Modern Virtual Memory Systems

Modern Virtual Memory Systems use address translation to provide the illusion of a large, private, and uniform storage.

<figure><img src=".gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

1\. Privacy means Protection:

• Several users/processes, each with their own private address space.

2\. Uniform storage means Demand Paging:

* ﻿﻿The ability to run programs larger than primary memory (DRAM).
* ﻿﻿Hides difference in machine configurations.
* ﻿﻿Price: Address translation on each memory reference.

user;

Primary

Memory

Swapping

Space (Disk)

Page tables in memory significantly increase average memory access time!

<figure><img src=".gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

Speeding Up Address Translation

* ﻿﻿Good Virtual Memory design should be fast (\~1 clock cycle) and space efficient.
* ﻿﻿Every instruction/data access needs address translation.
* ﻿﻿But if page tables are in memory, then we must perform a page table walk per instruction/data access:
* ﻿﻿Single-level page table: 2 memory accesses.
* ﻿﻿Two-level page table: 3 memory accesses.
* ﻿﻿Solution: Cache some translations in the .. Translation Lookaside Buffer (TLB).

<figure><img src=".gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

PTthe TLB Is a Cache for Address Translations

^ The Translation Lookaside Buffer (TLB)

• TLB hit:

→ Single-cycle translation

caches page table entries.

• TLB miss. → Page table walk to refill.

* TLB Reach: Size of largest virtual address space that can be simultaneously mapped by the TLB.
* ﻿﻿TLB design: 38-128 entries.
* ﻿﻿Typically fully associative (increase TLB reach by minimizing conflicting entries).

1°, Random/FIFO replacement policy.

<figure><img src=".gitbook/assets/image (17).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (18).png" alt=""><figcaption></figcaption></figure>

Tag, Index, and Offset

TIO for Virtual Addresses and Physical Addresses are unrelated!

<figure><img src=".gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>

Memory Access: TLB, Cache, DRAM, Page Table

Can a cache hold the requested data if the corresponding page is notin main memory?

No!

2\. On a memory reference, which block should we access first? When should we translate virtual addresses?

* ﻿﻿We will assume Physically Indexed, Physically Tagged caches (other designs exist).
* ﻿﻿This means TLB first, then cache.

<figure><img src=".gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (22).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

The TLB now does the translation.

Not the page table!!





Virtual Memory and the CPU Pipeline

\# Virtual Memory = address translation + protection + demand paging.

* Each instruction/data access = address translation + functional checks.
* ﻿﻿Should handle:

1\. TLB Miss: Needs a mechanism to refill TLB (usually done in hardware).

* ﻿﻿2. Page Fault (i.e., page on disk)
* ﻿﻿Needs a precise trap so that software handler can easily re-execute instruction after page retrieval

3\. Protection violation check

1 , \* A violation may abort the process, e.g., SEGFAULT.

<figure><img src=".gitbook/assets/image (25).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (24).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

Virtual Memory Action Flowchart

<figure><img src=".gitbook/assets/image (28).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

Handling Context Switches and TLBs

* ﻿﻿Context switches should be fast. Avoid DRAM/disk updures.
* ﻿﻿Keep all page tables for all currently running processes in DRAM.
* ﻿﻿Instead, ensure that all TLB entries refer to the active process.
* ﻿﻿The high-level context switch:

‹ The OS sets a timer. When it expires, perform a hardware interrupt.,

* ﻿﻿Trap handler saves all register values, including:
* ﻿﻿Program Counter (PC)
* ﻿﻿Page Table Register (SPTBR in RV321)
* ﻿﻿The memory address of the active process's page table.
* ﻿﻿Trap handler also sets all TLB entries to invalid. (other strategies exist)
* ﻿﻿Trap handler then loads in the next process's registers and returns to user mode.

<figure><img src=".gitbook/assets/image (29).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (30).png" alt=""><figcaption></figcaption></figure>

A Full, Page-Based Virtual Memory Machine

(Assume page tables are held in untranslated physical memory)

<figure><img src=".gitbook/assets/image (286).png" alt=""><figcaption></figcaption></figure>



<figure><img src=".gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (32).png" alt=""><figcaption></figcaption></figure>







[https://youtu.be/eVIsejli9hU](https://youtu.be/eVIsejli9hU)
