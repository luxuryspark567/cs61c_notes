# 35. TLB

## The Trap Handler

1. <mark style="color:yellow;">Save the state</mark> of the current program.
   * Save <mark style="color:yellow;">ALL of the registers</mark>!
2. ﻿﻿﻿Determine what caused the exception/interrupt. (﻿﻿In RISC-V, the exception <mark style="color:yellow;">cause</mark> can be inferred by <mark style="color:yellow;">the faulting instruction and its current pipeline stage</mark>.)
3. ﻿﻿﻿<mark style="color:red;">**Handle exception/interrupt (How??)**</mark>, then do one of two things:
   * <mark style="color:yellow;">Continue</mark> execution of the program:
     * ﻿﻿﻿<mark style="color:yellow;">Restore program state</mark>.
     * ﻿﻿﻿<mark style="color:yellow;">Return control to the program</mark>.
   * <mark style="color:yellow;">Terminate</mark> the program:
     * ﻿﻿﻿<mark style="color:yellow;">Free the program resources</mark>, etc.
     * ﻿﻿﻿<mark style="color:yellow;">Schedule a new program</mark>.

## Handling <mark style="color:yellow;">Context Switches</mark>

* Recall the context switch:
  * ﻿﻿OS switches between processes (i.e., programs) by changing the internal state of the processor.
  * ﻿﻿Allows a single processor to "simultaneously" run many programs.
* ﻿﻿At a high-level:
  * ﻿﻿The OS sets a <mark style="color:yellow;">timer</mark>. When it expires, perform <mark style="color:yellow;">a hardware interrupt</mark>.
  * ﻿﻿Trap handler <mark style="color:yellow;">saves all register values</mark>, including:
    * ﻿﻿<mark style="color:yellow;">Program Counter (PC)</mark>
    * ﻿﻿<mark style="color:yellow;">Page Table Register (SPTBR</mark> in RV321)
      * ﻿﻿The memory address of the active process's page table.
  * ﻿﻿Trap handler then <mark style="color:yellow;">loads in the next process's registers</mark> and <mark style="color:yellow;">returns to user mode</mark>.

## Handling Page Fault

* ﻿﻿Recall page faults:
  * An accessed page table entry has <mark style="color:yellow;">valid bit off</mark> → <mark style="color:yellow;">data is not in DRAM</mark>.
* ﻿﻿Page faults are handled by the trap handler.
  * ﻿﻿The <mark style="color:yellow;">page fault exception handler</mark> initiates transfers to/from disk and performs any page table updates.
  * ﻿﻿(If pages needs to <mark style="color:yellow;">be swapped from disk</mark>, <mark style="color:yellow;">perform context switch so that another process can use the CPU in the meantime</mark>.)
    * ﻿﻿ideally need a "precise trap" so that resuming a process is easy.
  * ﻿﻿Following the page fault, <mark style="color:yellow;">re-execute the instruction</mark>.
* ﻿﻿Side note: <mark style="color:yellow;">Write protection violations</mark> also trigger exceptions.

## System Calls and Launching Applications

* ﻿﻿A system call (<mark style="color:yellow;">syscall</mark>) is a "<mark style="color:yellow;">software interrupt</mark>" that allows a program to <mark style="color:yellow;">request a service from the operating system</mark>.
  * ﻿﻿<mark style="color:yellow;">Similar to a function call</mark>, except now <mark style="color:yellow;">executed by kernel</mark>.
  * ﻿﻿Examples:
    * ﻿﻿Creating and deleting files; reading/writing files;
    * ﻿﻿Accessing external devices (e.g., scanner);
    * ﻿﻿printf, malloc, etc. (ecalls in RISC-V); etc.
    * ﻿﻿Launch a new process
* Example: ﻿﻿Suppose shell (a user process) wants to <mark style="color:yellow;">launch a new app</mark>:
  * ﻿﻿Shell <mark style="color:yellow;">forks</mark> (in Linux): <mark style="color:yellow;">a syscall that traps into the OS kernel process</mark>
  * ﻿﻿OS (<mark style="color:yellow;">supervisor mode</mark>):&#x20;
    * <mark style="color:yellow;">Load program (see CALL);</mark>&#x20;
    * <mark style="color:yellow;">jump to start of main.</mark>&#x20;
    * <mark style="color:yellow;">Return to user mode</mark>.
  * ﻿﻿Shell: <mark style="color:yellow;">"wait" for main to return</mark> (join)



> #### **Kernel Mode vs. User Mode**
>
> In computer systems, **kernel mode** and **user mode** are the two modes of operation to ensure security and stability:
>
> 1. **Kernel Mode**:
>    * Full access to hardware and system resources.
>    * Used for executing privileged tasks (e.g., device drivers, interrupt handling, managing processes).
>    * Runs operating system code.
>    * No restrictions, which can lead to system crashes if errors occur.
> 2. **User Mode**:
>    * Restricted access to system resources.
>    * Used for running user applications.
>    * Needs system calls to access kernel-level functions.
>    * Errors in user mode typically don’t crash the entire system.
>
> This separation ensures stability and security by isolating user processes from the critical kernel operations.

> **Why wait after fork?**
>
>
>
> In a system that uses the **`fork()`** system call, the **parent process** creates a **child process**, and both processes run concurrently after the `fork()`. The **`wait()`** system call is typically used by the parent process to ensure that it **waits for the child process to complete** before proceeding. This is important for several reasons:
>
> #### 1. **Avoiding Zombie Processes**:
>
> * When a child process finishes executing, it still needs to send an exit status to the parent process. Until the parent retrieves this status, the child process remains in the "zombie" state.
> * If the parent does not call `wait()`, the child process cannot fully terminate, and it will remain a zombie process, occupying system resources.
> * The `wait()` system call allows the parent to **reap** the child process, collect its exit status, and release any system resources allocated to the child.
>
> #### 2. **Process Synchronization**:
>
> * The `wait()` system call ensures that the parent can **synchronize** its execution with the completion of the child process. Without `wait()`, the parent and child would run independently, which may lead to situations where the parent continues execution while the child is still doing important work (like I/O or computation).
> * In some cases, the parent may need to wait for the child to finish before proceeding with its own tasks (e.g., collecting results from the child process).
>
> #### 3. **Maintaining Control over Child Processes**:
>
> * Using `wait()` enables the parent to keep track of the child's **exit status** (whether it completed successfully or encountered an error).
> * This allows the parent to handle errors in the child process properly. For example, if the child returns a non-zero exit code (indicating an error), the parent can act on that information (like printing an error message or triggering some recovery steps).
>
> #### 4. **Preventing Orphaned Processes**:
>
> * If a parent process terminates before the child, the child process becomes an **orphan**. In that case, the child process is adopted by the **init process (PID 1)**.
> * However, if the parent calls `wait()`, it ensures that the child is properly handled and terminated, even if the parent finishes executing before the child.
>
> #### Example:
>
> Here’s a simple example in C using `fork()` and `wait()`:
>
> ```c
> cCopy code#include <stdio.h>
> #include <unistd.h>
> #include <sys/wait.h>
>
> int main() {
>     pid_t pid = fork();  // Create a new child process
>
>     if (pid == 0) {
>         // Child process
>         printf("This is the child process\n");
>         return 0;
>     } else {
>         // Parent process
>         wait(NULL);  // Wait for the child to finish
>         printf("This is the parent process\n");
>     }
>
>     return 0;
> }
> ```
>
> In this example:
>
> * The parent process calls `wait(NULL)` to wait for the child process to finish before printing "This is the parent process".
> * If the `wait()` were omitted, the parent could print "This is the parent process" before the child finishes.
>
> #### Conclusion:
>
> The `wait()` system call after `fork()` is critical for:
>
> * **Resource management** by preventing zombie processes.
> * **Process synchronization** to ensure the parent waits for the child when necessary.
> * **Error handling** and exit status retrieval from child processes.
>
> Without `wait()`, you could end up with unclean termination of processes, leading to resource leaks, synchronization issues, or unexpected behavior.

## What Happens at Boot?&#x20;

* The CPU executes instructions from <mark style="color:yellow;">some start address stored in Flash ROM</mark>.
* Then, the BIOS (Basic Input Output System) firmware loads the bootloader, which loads the OS kernel.
  * <mark style="color:yellow;">**BIOS**</mark>: <mark style="color:yellow;">Find a storage device and load the first sector (block of data)</mark>.
  * <mark style="color:yellow;">**Bootloader**</mark>. (stored on, e.g., disk) <mark style="color:yellow;">Load the OS kernel from disk into a location in memory and jump into it</mark>.
  * <mark style="color:yellow;">**OS Boot**</mark>. <mark style="color:yellow;">Initialize services, drivers, etc</mark>.
  * <mark style="color:yellow;">**Init**</mark>. <mark style="color:yellow;">Launch an application</mark> (e.g., Terminal/Desktop/...) that waits for input in loop.

## Caches vs. Primary Memory

* ﻿﻿Blocks, pages, (bytes, words) are all units of memory.
* ﻿﻿**Caches**: <mark style="color:yellow;">blocks</mark>
  * On modern systems, \~<mark style="color:yellow;">64B</mark>.
* **Memory**: <mark style="color:yellow;">pages</mark>
  * On modern systems, \~<mark style="color:yellow;">4KiB</mark>.

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

## Caches vs. Page Tables

"Cache" Paradigm: Data at each level is a quick-access copy of data at a lower level in the memory hierarchy.

* ﻿﻿A Page Table translates addresses.
  * ﻿﻿Page tables store physical page numbers, not data.
* Page tables facilitate Demand Paging.
  * Cache data pages in memory.
  * Access disk pages only when needed by the process.
  * Page Table keeps track of page status/location.

<figure><img src=".gitbook/assets/image (2).png" alt="" width="375"><figcaption></figcaption></figure>

## Caching vs. Demand Paging

<figure><img src=".gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

## Modern Virtual Memory Systems

Modern Virtual Memory Systems use address translation to provide the illusion of a large, private, and uniform storage.

1. Privacy means Protection:
   1. Several users/processes, each with their own private address space.
2. Uniform storage means Demand Paging:
   1. The ability to run programs larger than primary memory (DRAM).
   2. ﻿﻿Hides difference in machine configurations.

Price: Address translation on each memory reference.

Page tables in memory significantly increase average memory access time!

<figure><img src=".gitbook/assets/image (3).png" alt="" width="313"><figcaption></figcaption></figure>

## Speeding Up Address Translation

* ﻿﻿Good Virtual Memory design should be fast (\~1 clock cycle) and space efficient.
  * ﻿﻿Every instruction/data access needs address translation.
* ﻿﻿But if page tables are in memory, then we must perform a page table walk per instruction/data access:
  * ﻿﻿Single-level page table: 2 memory accesses.
  * ﻿﻿Two-level page table: 3 memory accesses.
* ﻿﻿Solution: Cache some translations in the .. Translation Lookaside Buffer (TLB).

<figure><img src=".gitbook/assets/image (4).png" alt="" width="343"><figcaption></figcaption></figure>

## The TLB Is a Cache for Address Translations

* The Translation Lookaside Buffer (TLB) caches page table entries.
  * TLB hit: → Single-cycle translation
  * TLB miss. → Page table walk to refill.
* TLB Reach: Size of largest virtual address space that can be simultaneously mapped by the TLB.
* ﻿﻿TLB design: 38-128 entries.
  * ﻿﻿Typically fully associative (increase TLB reach by minimizing conflicting entries).
  * Random/FIFO replacement policy.

<figure><img src=".gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

## Tag, Index, and Offset

TIO for Virtual Addresses and Physical Addresses are unrelated!

<figure><img src=".gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>

## Memory Access: TLB, Cache, DRAM, Page Table

1. Can a cache hold the requested data if the corresponding page is notin main memory? -> No!
2. On a memory reference, which block should we access first? When should we translate virtual addresses?
   1. We will assume Physically Indexed, Physically Tagged caches (other designs exist).
   2. This means TLB first, then cache.

<figure><img src=".gitbook/assets/image (22).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
The TLB now does the translation.

Not the page table!!
{% endhint %}

## Virtual Memory and the CPU Pipeline

Virtual Memory = address translation + protection + demand paging.

* Each instruction/data access = address translation + functional checks.
* ﻿﻿Should handle:
* TLB Miss: Needs a mechanism to refill TLB (usually done in hardware).
* ﻿﻿Page Fault (i.e., page on disk)
  * ﻿﻿Needs a precise trap so that software handler can easily re-execute instruction after page retrieval
* Protection violation check
  * A violation may abort the process, e.g., SEGFAULT.

<figure><img src=".gitbook/assets/image (24).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

## Virtual Memory Action Flowchart

<figure><img src=".gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

## Handling Context Switches and TLBs

* ﻿﻿Context switches should be fast. Avoid DRAM/disk updures.
  * ﻿﻿Keep all page tables for all currently running processes in DRAM.
  * ﻿﻿Instead, ensure that all TLB entries refer to the active process.
* ﻿﻿The high-level context switch:
  * The OS sets a timer. When it expires, perform a hardware interrupt.,
  * ﻿﻿Trap handler saves all register values, including:
    * ﻿﻿Program Counter (PC)
    * ﻿﻿Page Table Register (SPTBR in RV321)
      * ﻿﻿The memory address of the active process's page table.
  * ﻿﻿Trap handler also sets all TLB entries to invalid. (other strategies exist)
  * ﻿﻿Trap handler then loads in the next process's registers and returns to user mode.

## A Full, Page-Based Virtual Memory Machine

(Assume page tables are held in untranslated physical memory)

<figure><img src=".gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

[https://youtu.be/eVIsejli9hU](https://youtu.be/eVIsejli9hU)
