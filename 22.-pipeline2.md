# 22. Pipeline2

Five Stages

<figure><img src=".gitbook/assets/image (218).png" alt=""><figcaption></figcaption></figure>

## Single-cycle CPUU & pipelined CPU

* Pipelined CPU uses one clock for all stages, clock cycle time is limited by the slower statges.
* Shade is&#x20;

## Throughput

<figure><img src=".gitbook/assets/image (220).png" alt=""><figcaption></figcaption></figure>

Recaculate PC + 4 to avoid sending both PC and PC + 4 down pipeline.

<figure><img src=".gitbook/assets/image (221).png" alt=""><figcaption></figcaption></figure>

## Control is also pipelined

* Control signals are derived from the instruction. Like in the one-cycle CPU, contral is usually computed in ID stage
* Control informantion for later stages  is stored in pipeline registers

<figure><img src=".gitbook/assets/image (222).png" alt=""><figcaption></figcaption></figure>

Three Types of Pipeline Hazards&#x20;

A hazard is a situation in which a planned instruction cannot execute in the "proper" clock cycle.&#x20;

* 1\. Structural hazard:
  * Hardware does not support access across multiple instructions in the same cycle.&#x20;
* 2\. Data hazard: â€¢ Instructions have data dependency.
  * Need to wait for previous instruction to complete its data read/write.
* 3\. Control hazard:
  * Flow of execution depends on previous instruction.

## Structural Hazard

* Solution 1 (inefficient):
  * Instructions take turns using the resource.
  * Some instructions stall while the resource is busy.
* Solution 2: Add more hardware! hold all these limes?
  * Can always solve structural hazards by adding more HW.&#x20;
  * In our current CPU, structural hazards are not an issue.

Seperate IMEM and DMEM avoids structure hazard, and RV32I's required seperate IMEM and DMEM works.

<figure><img src=".gitbook/assets/image (223).png" alt=""><figcaption></figcaption></figure>

Data Hazards

* Data hazard:&#x20;
  * Instructions have data dependency.
  * Need to wait for previous instruction to complete its data read/write.
* Occurs when an instruction reads a register before a previous instruction has finished writing to that register.&#x20;
* Three cases to consider:&#x20;
  * 1\. Register access&#x20;
  * 2\. ALU Result&#x20;
  * 3\. Load data hazard (next time)

## Register Access

<figure><img src=".gitbook/assets/image (224).png" alt=""><figcaption></figcaption></figure>

## ALU Result&#x20;

<figure><img src=".gitbook/assets/image (225).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (227).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (228).png" alt=""><figcaption></figcaption></figure>



































