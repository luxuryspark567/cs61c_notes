# 33. VM I Intro

What does the core of the OS do?

* ﻿﻿OS is the (first) thing that runs when computer starts.
* ﻿﻿Starts services (100+).
* ﻿﻿File system, Network stack (Ethernet, WiFi, Bluetooth, ...), TTY (keyboard), etc.
* ﻿﻿Provides interaction with the outside world:
* ﻿﻿Finds and controls all devices in the machine in a general way:
* ﻿﻿• Relies on hardware specific "device drivers"
* ﻿﻿Loads, runs and manages programs:
* ﻿﻿Isolation: Each program runs (i.e., appears to run) in its own little world.
* ﻿﻿Resource-sharing: Multiple programs share the same resources:
* ﻿﻿Memory
* ﻿﻿1/0 devices: disk, keyboard, display, network, etc.
* ﻿﻿Time-sharing: Processor (CPU) runs .. multiple processes.

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Multiprogramming at a High Level

(more next time

* ﻿﻿The OS manages multiprogramming, which is running multiple applications (processes) "simultaneously" on one CPU. (vs. multiprocessing: running processes simultaneously on different
* CPUs. The OS also manages this.)
* ﻿﻿This is achieved via OS context switches, i.e., switches between processes very quickly (on the human time scale):
* ﻿﻿Save current process state (program counter, registers, etc.)
* ﻿﻿Load next process state to execute next instruction on CPU
* ﻿﻿Do not switch out data between main memory and disk! Too costly...

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Main Memory and Secondary Memory

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

Main Memory is DRAM

. .

* ﻿﻿Dynamic Random Access Memory:
* ﻿﻿Latency to access first word: \~10ns (\~30-40\
  processor cycles), each successive (0.5ns - Ins)
* ﻿﻿Each access brings 64 bits, supports 'bursts'
* ﻿﻿$3/GiB
* ﻿﻿Data is impermanent:
* ﻿﻿Dynamic: capacitors store bits, so needs periodic refresh to maintain charge
* ﻿﻿Volatile: when power is removed, loses data.
* ﻿﻿Contrast with SRAM (for caches):
* ﻿﻿Static (no capacitors) but still volatile
* ﻿﻿Faster (0.5 ns)/more expensive/lower density

<figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Storage / "Disk" / Secondary Memory

* ﻿﻿Attached as a peripheral 1/0 device. Non-volatile
* ﻿﻿Solid-State Drive (SSD)

• Hard Disk Drive (HDD),

• Access: 40-100us

• Access: <5-10ms

(\~100k proc. cycles)

(10-20M proc. cycles)

\- $0.05-0.5/GB

\- $0.01-0.1/GB

• Usually flash memory

\- Mechanical

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>



<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

Aside 2... What about SSDs?

* ﻿﻿Made with transistors (nothing mechanical/rotating)
* ﻿﻿Operates like a "Ginormous" register file.
* ﻿﻿Furthermore, does not "forget" when power is off (non-volatile)
* ﻿﻿Fast access to all locations, regardless of address ‹ • Still much slower than register, DRAM.

3D NAND

Architecture

• Read/write blocks, not bytes.

SGD

Bit Line

BL Contact

• Potential reliability issues...

WL

• Some unusual requirements:

SGS

• Can't erase single bits

Memory Holes

\- only entire blocks

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

Virtual Memory

* ﻿﻿Virtual memory is the next level in the memory hierarchy:
* ﻿﻿Give each process the illusion of a full memory address space that it has completely for itself.
* ﻿﻿Under the hood: working set of pages reside in main memory; other pages are in disk.
* ﻿﻿Benefits:
* ﻿﻿Demand paging provides the ability to run programs larger than the primary memory (DRAM).
* ﻿﻿OS can share memory and protect programs from each other.
* ﻿﻿Hides differences between machine configurations.
* ﻿﻿Today, more important for protection than space management.
* ﻿﻿(Historically, virtual memory predates caches.)

<figure><img src=".gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Virtual vs. Physical Addresses

* ﻿﻿Address Space: set of addresses for all available memory locations.
* ﻿﻿Now, two kinds of memory addresses!
* ﻿﻿Virtual Address Space
* ﻿﻿Set of addresses that the user program knows about
* ﻿﻿Physical Address Space
* ﻿﻿Set of addresses that map to actual physical locations in memory
* ﻿﻿Hidden from user applications

\- For each program, a memory manager maps (translates) between these two address spaces.

<figure><img src=".gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

Processes use virtual addresses.

Many processes, all using same (conflicting) addresses

<figure><img src=".gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

OS Virtual Memory Management Responsibilities

1. ﻿﻿﻿Map virtual addresses to physical addresses.
2. ﻿﻿﻿Use both memory and disk.

* ﻿﻿Give illusion of larger memory by storing some content on disk.
* ﻿﻿Disk is usually much larger and slower than DRAM.

3\. Protection:

• Isolate memory between processes.

<figure><img src=".gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

Paged Memory

• The concept of "paged memory" dominates:

* ﻿﻿Physical memory (DRAM) is broken into pages.
* ﻿﻿A disk access loads an entire page into memory.
* ﻿﻿Typical page size: 4 KiB+ (on modern OSs)
* ﻿﻿Need 12 bits of page offsetto address all 4 KiB bytes.
* ﻿﻿If virtual and physical pages are the same size, then memory translation maps

Virtual address (e.g. 32 Bits)

Virtual Page Number (VPN)

VPN (20 bits)

to a

Physical Page Number (PPN).

<figure><img src=".gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

Translation: How a Program Accesses Memory

1. ﻿﻿﻿Program executes a load specifying a virtual address (VA).
2. ﻿﻿﻿Computer translates VA to the physical address (PA) in memory.

* ﻿﻿Extract virtual page number (VPN) from VA, e.g., top 20 bits
* ﻿﻿Look up physical page number (PPN) in page table
* ﻿﻿Construct PA: physical page number + offset (from virtual address)

1. ﻿﻿﻿If the physical page is not in memory, then OS loads it in from disk.
2. ﻿﻿﻿The OS reads memory at the PA and returns the data to the program.

<figure><img src=".gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>



<figure><img src=".gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

What Do Page Tables Look Like?

* ﻿﻿E.g., 32-bit virtual address space, 4-KiB pages
* ﻿﻿232 virtual addresses / (212 B/page)\
  \= 220 virtual page numbers
* ﻿﻿One Page Table per process:

0x00000

• One entry per virtual page number.

0x60000

• Entry has physical page number (or disk address) as well as status bits.

Note: A Page Table is NOT a cache!!

OxFFFFF

* ﻿﻿A Page Table does not have data!\
  It is a lookup table.
* ﻿﻿All VPNs have a valid entry.

1 1 " But if it helps you, "no tags; index is VPN"

<figure><img src=".gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

OS Virtual Memory Management Responsibilities

1. ﻿﻿﻿Map virtual addresses to physical addresses.
2. ﻿﻿﻿Use both memory and disk.

* ﻿﻿Give illusion of larger memory by storing some content on disk.
* ﻿﻿Disk is usually much larger and slower than DRAM.

3\. Protection:

* ﻿﻿Isolate memory between processes.
* ﻿﻿Each process gets dedicated "private" memory.
* ﻿﻿Errors in one program won't corrupt memory of other programs.
* ﻿﻿Prevent user programs from messing with OS's memory.

What if process tries to modify instructions or system data?

<figure><img src=".gitbook/assets/image (17).png" alt=""><figcaption></figcaption></figure>

Protection with Page Tables (1/2)

• Each process has a

Page table

dedicated page table.

• OS keeps track of which process is active.

Athmetic-Lage

Unit (ALL)

* ﻿﻿Isolation: Assign processes different pages in DRAM
* ﻿﻿Prevents accessing other processors' memory
* ﻿﻿Page tables managed by OS

Page table

* ﻿﻿Sharing is also possible:
* ﻿﻿OS may assign same physical page to several processes, e.g., system data
*
  * Page Table Entry also includes a write protection bit.
  * ﻿﻿If on, then page is\
    "protected":
  * ﻿﻿e.g., program code, system data, etc.
  * ﻿﻿Writing to a protected page triggers an exception.\
    Exceptions are handled by\
    OS. (more later)

<figure><img src=".gitbook/assets/image (18).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>



