# 8. RISC-V Data Transfer

## Review

* Addition
  * add rd, rs1, rs2
  * R\[rd] = R\[rs1] + R\[rs2]
* subtraction
  * sub rd, rs1, rs2
  * R\[rd] = R\[rs1] - R\[rs2]
* Add immediate
  * addi rd, rs1, imm
  * R\[rd] = R\[rs1] + imm

## Data Transfer: Load from and Store to memory

<figure><img src=".gitbook/assets/image (82).png" alt=""><figcaption></figcaption></figure>

## Data Transfer Instructions

* Load from Memory to Register
  * C code: \
    `int  A[100];` \
    `g = h + A[3];`
  * Using Load Word (lw) in RISC-V:\
    `lw  x10,12(x15) # Reg x10 gets A[3]`\
    `add x11,x12,x10 # g = h + A[3]`
  * Note:
    * x15 – base register (pointer to A\[0])
    * 12 – offset in bytes
    * Offset must be a constant known at assembly time
* Store from Register to Memory
  * C code\
    `int  A[100];`\
    `A[10] = h + A[3];`
  * Using Store Word (sw) in RISC-V:\
    `lw  x10,12(x15)  # Temp reg x10 gets A[3]`\
    `add x10,x12,x10  # Temp reg x10 gets h + A[3]`\
    `sw  x10,40(x15)  # A[10] = h + A[3]`
  * Note:
    * x15 – base register (pointer)
    * 12,40 – offsets in bytes
    * x15+12 and x15+40 must be multiples of 4
* Loading and Storing Bytes
  * In addition to word data transfers (lw, sw), RISC-V has byte data transfers:&#x20;
    * load byte: lb (sign extending: <mark style="color:red;">extend the sign bits to fill register</mark>)
    * store byte: sb&#x20;
  * Same format as lw, sw&#x20;
  * E.g., lb x10,3(x11)&#x20;
  * contents of memory location with address = sum of “3” + contents of register x11 is copied to <mark style="color:red;">the low byte position of</mark> register x10.
  * RISC-V also has “unsigned byte” loads (lbu) which <mark style="color:red;">zero extends to fill register (zero extending)</mark>. Why no unsigned store byte ‘sbu’?

<figure><img src=".gitbook/assets/image (84).png" alt=""><figcaption></figcaption></figure>

## Conclusion

* Memory is byte-addressable, but lw and sw access one word at a time.
* A pointer (used by lw and sw) is just a memory address, we can add to it or subtract from it (using offset).
* Big- vs Little Endiano
  * Tip: draw lowest byte on the right
* New Instructions:
  * `lw, sw, lb, sb, lbu`
