# 16. State

Register is used to hold up the transfer of data to adder.

<figure><img src=".gitbook/assets/image (93).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (94).png" alt=""><figcaption></figcaption></figure>

## Flip-flop&#x20;

* The output flips and flops between and 0,1
* D is “data”, Q is “output”
* Also called “<mark style="color:yellow;">D-type Flip-Flop</mark>” There used to be other types of flip-flops
* <mark style="color:yellow;">On the</mark> <mark style="color:red;">rising edge</mark> <mark style="color:yellow;">of the clock, the input d is sampled and transferred to the output. At all other times, the input d is ignored.</mark>

<figure><img src=".gitbook/assets/image (95).png" alt=""><figcaption></figcaption></figure>

### Timing

Rising Edge-triggered or Falling Edge-triggered

<figure><img src=".gitbook/assets/image (96).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (97).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

## Accumulator

<figure><img src=".gitbook/assets/image (139).png" alt="" width="248"><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

* Shadow area in Si: <mark style="color:yellow;">Xi is changing and not not stable, thus it could be new value and old value at the same time, thus it's a undefined state</mark>.



* reset signal shown.&#x20;
* Also, in practice X might not arrive to the adder at the same time as Si-1&#x20;
* Si temporarily is wrong, but register always captures correct value.&#x20;
* In good circuits, instability never happens around rising edge of clk.

## Maximum Clock Frequency

<figure><img src=".gitbook/assets/image (101).png" alt="" width="375"><figcaption></figcaption></figure>

<mark style="color:yellow;">Max Delay</mark> = <mark style="color:blue;">CLK-to-Q Delay</mark> + <mark style="color:yellow;">CL Delay</mark> + <mark style="color:red;">Setup Time</mark>

## Pipeline to improve performance

* Extra Registers are often added to help speed up the clock rate.
* TradeOff: Through put is larger, but the latency for one job is longer.

<mark style="color:yellow;">Max Delay</mark> = <mark style="color:blue;">CLK-to-Q Delay</mark> + <mark style="color:yellow;">CL Delay (Adder)</mark> + <mark style="color:yellow;">CL Delay (Shifter)</mark> + <mark style="color:red;">Setup Time</mark>

<figure><img src=".gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">Max Delay 1</mark> = <mark style="color:blue;">CLK-to-Q Delay</mark> + <mark style="color:yellow;">CL Delay (Adder)</mark> + <mark style="color:red;">Setup Time</mark>

<mark style="color:yellow;">Max Delay 2</mark> = <mark style="color:blue;">CLK-to-Q Delay</mark> + <mark style="color:yellow;">CL Delay (Shifter)</mark> + <mark style="color:red;">Setup Time</mark>

<figure><img src=".gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

## Finite State Machines

Tipical Application:&#x20;

* <mark style="color:yellow;">FSM to detect the occurrence of 3 consecutive 1’s in the input.</mark>
  * <mark style="color:yellow;">PS: Present state;</mark>
  * <mark style="color:yellow;">NS: Next state;</mark>
* <mark style="color:yellow;">Recognize pattern: Design</mark> an FSM that will output a 1 if it recognizes the regex pattern {10+1}. (That is, if the input forms a pattern of a 1, followed by one or more 0s, followed by a 1.)

<figure><img src=".gitbook/assets/image.png" alt="" width="375"><figcaption></figcaption></figure>





Controlled by the clock: on each clock cycle the machine checks the inputs and moves to a new state and produces a new output.

<figure><img src=".gitbook/assets/image (104).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (137).png" alt="" width="375"><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

## General Model for Synchronous Systems

<figure><img src=".gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

* Collection of CL blocks <mark style="color:yellow;">separated by registers</mark>.&#x20;
* Registers may be back-to-back and CL blocks may be back-to-back.&#x20;
* Feedback is optional.&#x20;
* <mark style="color:yellow;">Clock signal(s) connects</mark> <mark style="color:red;">only to</mark> <mark style="color:yellow;">clock input of registers.</mark>





