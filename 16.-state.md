# 16. State

Register is used to hold up the transfer of data to adder.

<figure><img src=".gitbook/assets/image (93).png" alt="" width="301"><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (94).png" alt="" width="375"><figcaption></figcaption></figure>

## Flip-flop&#x20;

* The output flips and flops between and 0,1
* D is “data”, Q is “output”
* Also called “<mark style="color:yellow;">D-type Flip-Flop</mark>” There used to be other types of flip-flops
* <mark style="color:yellow;">On the</mark> <mark style="color:red;">rising edge</mark> <mark style="color:yellow;">of the clock, the input d is sampled and transferred to the output. At all other times, the input d is ignored.</mark>

<figure><img src=".gitbook/assets/image (95).png" alt="" width="375"><figcaption></figcaption></figure>

### Timing

Rising Edge-triggered or Falling Edge-triggered

<figure><img src=".gitbook/assets/image (97).png" alt="" width="375"><figcaption><p>Clock to q delay</p></figcaption></figure>

<figure><img src=".gitbook/assets/image (98).png" alt=""><figcaption><p>Timing</p></figcaption></figure>

## Accumulator

<figure><img src=".gitbook/assets/image (139).png" alt="" width="248"><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

* Also, in practice X might not arrive to the adder at the same time as S\_{i-1}&#x20;
* S\_i temporarily is wrong, but register always captures correct value.&#x20;
* In good circuits, instability never happens around rising edge of clk.
* Shadow area in S\_i: <mark style="color:yellow;">X\_i is changing and not not stable, thus it could be new value and old value at the same time, thus it's a undefined state</mark>.

<figure><img src=".gitbook/assets/image (1).png" alt="" width="375"><figcaption></figcaption></figure>

* Critical Path(CP): The longest delay between two state element
  * CP = clk-to-q(Reg1) + longest CL delay + setup time(Reg2)
* Setup time and combinatorial delay constraint: \
  Clock period >= clk-to-q delay + longest combinatorial delay + setup time
  * After the rising edge, we have to wait clk-to-q delay for the Q output to change
  * Then, we have to wait the longest combinatorial delay for the result to appear at the D input
  * Then, we have to hold that D input stable for the setup time
* Hold time constraint:\
  Hold time <= clk-to-q delay + shortest combinatorial delay
  * After the rising edge, we have to wait clk-to-q delay for the Q output to change
  * Then, after the shortest combinatorial delay, one of the D inputs will change
  * We need the hold time to be over by the time the D input changes.



{% hint style="info" %}
Normally, hold time is always small enough.

<mark style="color:yellow;">Hold-time is defined as the time needed after the rising edge, thus the D inputs should remain remain stable for at least hold-time period. That's why (the clk-to-q delay + shortest combinatorial delay) is used to constrain hold-time.</mark>
{% endhint %}

## Maximum Clock Frequency

<figure><img src=".gitbook/assets/image (101).png" alt="" width="375"><figcaption></figcaption></figure>

<mark style="color:yellow;">Max Delay</mark> = <mark style="color:blue;">CLK-to-Q Delay</mark> + <mark style="color:yellow;">CL Delay</mark> + <mark style="color:red;">Setup Time</mark>

## Pipeline to improve performance

* Extra Registers are often added to help speed up the clock rate.
* TradeOff: Through put is larger, but the latency for one job is longer.

<mark style="color:yellow;">Max Delay</mark> = <mark style="color:blue;">CLK-to-Q Delay</mark> + <mark style="color:yellow;">CL Delay (Adder)</mark> + <mark style="color:yellow;">CL Delay (Shifter)</mark> + <mark style="color:red;">Setup Time</mark>

<figure><img src=".gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">Max Delay 1</mark> = <mark style="color:blue;">CLK-to-Q Delay</mark> + <mark style="color:yellow;">CL Delay (Adder)</mark> + <mark style="color:red;">Setup Time</mark>

<mark style="color:yellow;">Max Delay 2</mark> = <mark style="color:blue;">CLK-to-Q Delay</mark> + <mark style="color:yellow;">CL Delay (Shifter)</mark> + <mark style="color:red;">Setup Time</mark>

<figure><img src=".gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

## Finite State Machines

Tipical Application:&#x20;

* <mark style="color:yellow;">FSM to detect the occurrence of 3 consecutive 1’s in the input.</mark>
  * <mark style="color:yellow;">PS: Present state;</mark>
  * <mark style="color:yellow;">NS: Next state;</mark>
* <mark style="color:yellow;">Recognize pattern: Design</mark> an FSM that will output a 1 if it recognizes the regex pattern {10+1}. (That is, if the input forms a pattern of a 1, followed by one or more 0s, followed by a 1.)

<figure><img src=".gitbook/assets/image (4).png" alt="" width="375"><figcaption></figcaption></figure>





Controlled by the clock: on each clock cycle the machine checks the inputs and moves to a new state and produces a new output.

<figure><img src=".gitbook/assets/image (104).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (137).png" alt="" width="375"><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

## General Model for Synchronous Systems

<figure><img src=".gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

* Collection of CL blocks <mark style="color:yellow;">separated by registers</mark>.&#x20;
* Registers may be back-to-back and CL blocks may be back-to-back.&#x20;
* Feedback is optional.&#x20;
* <mark style="color:yellow;">Clock signal(s) connects</mark> <mark style="color:red;">only to</mark> <mark style="color:yellow;">clock input of registers.</mark>





